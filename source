===========src/components/bottom_bar.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Modifier, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
}; // Appæ§‹é€ ä½“ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/// Bottom Bar ã‚’æç”»ã—ã¾ã™ã€‚ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã€è¡Œæ•°ãªã©ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
pub fn render_bottom_bar(f: &mut Frame, area: Rect, app: &App) {
    let cursor_pos = app.editor.cursor.get_current_pos();
    let total_lines = app.editor.buffer.lines().count();
    let _col_count = if let Some(line) = app.editor.buffer.lines().nth(cursor_pos.1 as usize) {
        // ç¾åœ¨ã®è¡Œã®è«–ç†çš„ãªæ–‡å­—æ•°
        line.chars().count()
    } else {
        0
    };

    // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã¨å‰æ™¯è‰²ã‚’å–å¾—
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    let text_content = format!(
        " Ln {}, Col {} | Total Lines: {} ",
        cursor_pos.1.saturating_add(1), // 1-indexed line number
        cursor_pos.0.saturating_add(1), // 1-indexed column number
        total_lines
    );

    let paragraph = Paragraph::new(Line::from(text_content))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(theme_bg)),
        ) // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã‚’é©ç”¨
        .alignment(Alignment::Right) // å³å¯„ã›
        .style(Style::default().fg(theme_fg).add_modifier(Modifier::BOLD)); // ãƒ†ãƒ¼ãƒã®å‰æ™¯è‰²ã‚’é©ç”¨

    f.render_widget(paragraph, area);
}
===========
===========src/components/popup.rs
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Clear, Paragraph},
};

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum ExitPopupOption {
    SaveAndExit,
    DiscardAndExit,
    Cancel,
}

#[derive(Debug, PartialEq, Eq)]
pub enum ExitPopupResult {
    SaveAndExit,
    DiscardAndExit,
    Cancel,
    None,
}

pub struct ExitPopupState {
    pub selected_option: ExitPopupOption,
    pub input_text: String,
    pub input_mode: bool,
}

impl Default for ExitPopupState {
    fn default() -> Self {
        Self {
            selected_option: ExitPopupOption::SaveAndExit,
            input_text: String::new(),
            input_mode: false,
        }
    }
}

impl ExitPopupState {
    pub fn previous(&mut self) {
        self.selected_option = match self.selected_option {
            ExitPopupOption::SaveAndExit => ExitPopupOption::Cancel,
            ExitPopupOption::DiscardAndExit => ExitPopupOption::SaveAndExit,
            ExitPopupOption::Cancel => ExitPopupOption::DiscardAndExit,
        };
    }
    pub fn next(&mut self) {
        self.selected_option = match self.selected_option {
            ExitPopupOption::SaveAndExit => ExitPopupOption::DiscardAndExit,
            ExitPopupOption::DiscardAndExit => ExitPopupOption::Cancel,
            ExitPopupOption::Cancel => ExitPopupOption::SaveAndExit,
        };
    }
}

/// ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ç¨®é¡
pub enum PopupKind<'a> {
    Exit,
    Input { message: &'a str, input: &'a str },
}

/// ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æç”»ã®å…±é€šé–¢æ•°
pub fn render_popup(f: &mut Frame, area: Rect, kind: PopupKind, state: &ExitPopupState) {
    let (title, lines, popup_height) = match kind {
        PopupKind::Exit => {
            let text = vec![
                Line::from(Span::raw("")),
                Line::from(Span::raw(
                    "You have unsaved changes. Do you want to save them?",
                )),
                Line::from(Span::raw("")),
                render_option(
                    state.selected_option,
                    ExitPopupOption::SaveAndExit,
                    "  [S]ave and Exit  ",
                ),
                render_option(
                    state.selected_option,
                    ExitPopupOption::DiscardAndExit,
                    "  [D]iscard and Exit  ",
                ),
                render_option(
                    state.selected_option,
                    ExitPopupOption::Cancel,
                    "  [C]ancel  ",
                ),
                Line::from(Span::raw("")),
            ];
            ("Unsaved Changes", text, 9)
        }
        PopupKind::Input { message, input } => {
            let text = vec![
                Line::from(Span::raw("")),
                Line::from(Span::styled(message, Style::default().fg(Color::Yellow))),
                Line::from(Span::raw("")),
                Line::from(Span::styled(
                    format!("> {}", input),
                    Style::default().fg(Color::White),
                )),
                Line::from(Span::raw("")),
                Line::from(Span::styled(
                    "Backspaceã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
                    Style::default().fg(Color::DarkGray),
                )),
            ];
            ("Input", text, 8)
        }
    };

    let block = Block::default()
        .title(Span::styled(
            title,
            Style::default()
                .fg(Color::LightRed)
                .add_modifier(Modifier::BOLD),
        ))
        .title_alignment(Alignment::Center)
        .borders(Borders::ALL)
        .style(Style::default().bg(Color::DarkGray).fg(Color::White));

    let popup_width = 60;
    let popup_area = Rect::new(
        area.width.saturating_sub(popup_width) / 2,
        area.height.saturating_sub(popup_height) / 2,
        popup_width,
        popup_height,
    );

    f.render_widget(Clear, popup_area);
    f.render_widget(
        Paragraph::new(lines)
            .block(block)
            .alignment(Alignment::Center),
        popup_area,
    );
}

fn render_option<'a>(
    current_selection: ExitPopupOption,
    option_type: ExitPopupOption,
    text: &'a str,
) -> Line<'a> {
    let mut style = Style::default().fg(Color::White);
    if current_selection == option_type {
        style = style.add_modifier(Modifier::BOLD).bg(Color::Blue);
    }
    Line::from(Span::styled(text, style))
}
===========
===========src/components/suggest.rs
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};
use crate::app::InputOverlay;
use crate::app::App;

/// ã‚µã‚¸ã‚§ã‚¹ãƒˆãƒãƒ¼ã‚„æ¤œç´¢ãƒ»ç½®æ›ãƒãƒ¼ãªã©ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤UIã‚’æç”»ã—ã¾ã™ã€‚
pub fn render_overlay(f: &mut Frame, app: &App) {
    match &app.input_overlay {
        InputOverlay::Search { query, .. } => {
            let area = Rect {
                x: 0,
                y: f.area().height - 2,
                width: f.area().width,
                height: 2,
            };
            let text = format!("ğŸ” æ¤œç´¢: {}", query);
            let para = Paragraph::new(text).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::Replace { query, replace, focus_replace, .. } => {
            let area = Rect {
                x: 0,
                y: f.area().height - 3,
                width: f.area().width,
                height: 3,
            };
            let text = format!(
                "ğŸ” æ¤œç´¢: {}  â¬‡ ç½®æ›: {}{}",
                query,
                replace,
                if *focus_replace { " â†" } else { "" }
            );
            let para = Paragraph::new(text).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::Suggest { suggestions, selected, .. } => {
            let area = Rect {
                x: 10,
                y: f.area().height - 5,
                width: 30,
                height: suggestions.len().min(5) as u16 + 2,
            };
            let mut lines = vec![];
            for (i, s) in suggestions.iter().enumerate() {
                if i == *selected {
                    lines.push(Line::from(Span::styled(s, Style::default().bg(Color::Blue))));
                } else {
                    lines.push(Line::from(s.as_str()));
                }
            }
            let para = Paragraph::new(lines).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::None => {}
    }
}
===========
===========src/components/middle_block/editor_block.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Stylize},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph, Wrap},
};
use syntect::parsing::SyntaxReference;

/// ã‚¨ãƒ‡ã‚£ã‚¿æœ¬ä½“ (ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚«ãƒ¼ã‚½ãƒ«) ã‚’æç”»ã—ã¾ã™ã€‚
pub fn render_editor_block(f: &mut Frame, area: Rect, app: &App) {
    // æŠ˜è¿”ã—ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ: wrapå¹…ã‚’word_wrap_enabledã§åˆ‡ã‚Šæ›¿ãˆ
    let editor_area_width = super::left_block::get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX // wrapã—ãªã„å ´åˆã¯éå¸¸ã«å¤§ããªå€¤
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let total_visual_lines = visual_lines.len();
    let start = app.editor.scroll_offset_y as usize;
    let end = (start + area.height as usize).min(total_visual_lines);
    let visible_lines = &visual_lines[start..end];

    let mut lines_for_paragraph: Vec<Line> = Vec::new();
    let syntax: &SyntaxReference = app
        .highlighter
        .syntax_set
        .find_syntax_by_name(&app.current_syntax_name)
        .unwrap_or_else(|| app.highlighter.syntax_set.find_syntax_plain_text());

    // é¸æŠç¯„å›²ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
    let selection_range = app.editor.get_selection_range();
    let (sel_start_byte, sel_end_byte) = if let Some((sel_start, sel_end)) = selection_range {
        (sel_start, sel_end)
    } else {
        (usize::MAX, usize::MAX)
    };

    // å„visual lineã”ã¨ã«æç”»
    for (buf_idx, wrap_idx, line_str) in visible_lines.iter() {
        let mut spans: Vec<Span> = Vec::new();
        let highlighted_segments = app.highlighter.highlight_line(line_str, syntax);
        // visual lineã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
        let global_line_start_byte_offset = app.editor.get_visual_line_global_offset(*buf_idx, *wrap_idx, wrap_width);
        let global_line_end_byte_offset = global_line_start_byte_offset + line_str.len();
        let line_selected = sel_start_byte < global_line_end_byte_offset && sel_end_byte > global_line_start_byte_offset;
        let mut current_byte_offset_in_line = 0;
        for (syntect_style, text) in highlighted_segments {
            let base_style = super::super::super::app::features::syntax::Highlighter::convert_syntect_style_to_ratatui_style(syntect_style);
            let segment_global_start_offset = global_line_start_byte_offset + current_byte_offset_in_line;
            let segment_global_end_offset = segment_global_start_offset + text.len();
            if line_selected {
                let seg_sel_start = sel_start_byte.max(segment_global_start_offset);
                let seg_sel_end = sel_end_byte.min(segment_global_end_offset);
                if seg_sel_start < seg_sel_end {
                    let rel_sel_start = seg_sel_start - segment_global_start_offset;
                    let rel_sel_end = seg_sel_end - segment_global_start_offset;
                    let left = &text[..rel_sel_start];
                    let mid = &text[rel_sel_start..rel_sel_end];
                    let right = &text[rel_sel_end..];
                    if !left.is_empty() {
                        spans.push(Span::styled(left.to_string(), base_style));
                    }
                    if !mid.is_empty() {
                        spans.push(Span::styled(
                            mid.to_string(),
                            base_style.bg(Color::Rgb(50, 50, 100)),
                        ));
                    }
                    if !right.is_empty() {
                        spans.push(Span::styled(right.to_string(), base_style));
                    }
                } else {
                    spans.push(Span::styled(text.to_string(), base_style));
                }
            } else {
                spans.push(Span::styled(text.to_string(), base_style));
            }
            current_byte_offset_in_line += text.len();
        }
        lines_for_paragraph.push(Line::from(spans));
    }
    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã•ã«æº€ãŸãªã„å ´åˆã¯ç©ºè¡Œã§åŸ‹ã‚ã‚‹
    while lines_for_paragraph.len() < area.height as usize {
        lines_for_paragraph.push(Line::from(vec![Span::raw("")]));
    }
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();
    let mut paragraph = Paragraph::new(Text::from(lines_for_paragraph))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .bg(theme_bg)
                .fg(theme_fg),
        );
    // æŠ˜è¿”ã—è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
    if app.word_wrap_enabled {
        paragraph = paragraph.wrap(Wrap { trim: false });
    } else {
        // æŠ˜è¿”ã—ç„¡åŠ¹æ™‚ã¯xæ–¹å‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ–
        paragraph = paragraph.scroll((0, app.editor.scroll_offset_x as u16));
    }
    f.render_widget(paragraph, area);
    // ã‚«ãƒ¼ã‚½ãƒ«æç”»
    // visual_lineså†…ã§ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ¢ã™
    let (cursor_visual_idx, cursor_x_in_visual) = app.editor.get_cursor_visual_position(wrap_width);
    let cursor_screen_y = area.y + (cursor_visual_idx as u16).saturating_sub(app.editor.scroll_offset_y);
    let cursor_screen_x = area.x + (cursor_x_in_visual as u16).saturating_sub(app.editor.scroll_offset_x);
    if cursor_screen_x < area.right() && cursor_screen_y < area.bottom() {
        f.set_cursor_position((cursor_screen_x, cursor_screen_y));
    }
}
===========
===========src/components/middle_block/right_block.rs
use crate::app::{App, LineStatus};
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};

/// Right Block ã‚’æç”»ã—ã¾ã™ã€‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã¨å·®åˆ†ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
pub fn render_right_block(f: &mut Frame, area: Rect, app: &App) {
    // --- ä¿®æ­£: visual lineæ•°ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®— ---
    let editor_area_width = crate::components::middle_block::left_block::get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let visual_lines_count = visual_lines.len() as u16;
    let viewport_height = area.height;

    let mut scrollbar_content: Vec<Line> = Vec::new();

    // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã‚’å–å¾—
    let theme_bg = app.highlighter.get_background_color();

    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã€Œã¤ã¾ã¿ã€ã®ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
    let thumb_height = if visual_lines_count > 0 {
        ((viewport_height as f32 / visual_lines_count as f32) * viewport_height as f32) as u16
    } else {
        0
    };
    let thumb_height = thumb_height.max(1); // æœ€å°1æ–‡å­—ã®é«˜ã•

    // ã¤ã¾ã¿ã®ä¸Šç«¯ä½ç½®
    let thumb_start_y = if visual_lines_count > 0 {
        ((app.editor.scroll_offset_y as f32 / visual_lines_count as f32) * viewport_height as f32) as u16
    } else {
        0
    };
    let thumb_start_y = thumb_start_y.min(viewport_height.saturating_sub(thumb_height));

    for y_on_screen in 0..viewport_height {
        let mut spans: Vec<Span> = Vec::new();
        let mut line_content = String::new();

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®æç”»
        if y_on_screen >= thumb_start_y && y_on_screen < thumb_start_y + thumb_height {
            // ã¤ã¾ã¿ã®è‰²
            line_content.push('#');
        } else {
            // ãƒ¬ãƒ¼ãƒ«éƒ¨åˆ†ã®è‰²
            line_content.push('|');
        }
        spans.push(Span::styled(
            line_content,
            Style::default().fg(Color::DarkGray),
        )); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®è‰²ã¯å›ºå®š

        // å·®åˆ†ãƒãƒ¼ã‚«ãƒ¼ã®æç”» (visual lineã«å¯¾å¿œã™ã‚‹è«–ç†è¡Œã§åˆ¤å®š)
        let visual_idx = (app.editor.scroll_offset_y + y_on_screen) as usize;
        let buf_idx = if visual_idx < visual_lines.len() {
            visual_lines[visual_idx].0
        } else {
            usize::MAX
        };
        if buf_idx != usize::MAX {
            let status = app
                .line_statuses
                .get(buf_idx)
                .copied()
                .unwrap_or(LineStatus::Unchanged);

            let diff_style = match status {
                LineStatus::Modified => Style::default().fg(Color::Yellow),
                LineStatus::Added => Style::default().fg(Color::Green),
                LineStatus::Unchanged => Style::default().fg(Color::DarkGray),
            };
            let marker_char = match status {
                LineStatus::Modified => '~',
                LineStatus::Added => '+',
                LineStatus::Unchanged => ' ',
            };
            spans.push(Span::styled(marker_char.to_string(), diff_style));
        } else {
            spans.push(Span::raw(" "));
        }
        scrollbar_content.push(Line::from(spans));
    }

    let block = Block::default()
        .borders(Borders::LEFT) // å·¦å´ã«å¢ƒç•Œç·š
        .style(Style::default().bg(theme_bg)); // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã‚’é©ç”¨

    let paragraph = Paragraph::new(scrollbar_content)
        .block(block)
        .alignment(Alignment::Left); // å·¦å¯„ã›

    f.render_widget(paragraph, area);
}
===========
===========src/components/middle_block/left_block.rs
use crate::app::{App, LineStatus};
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};

/// ã‚¨ãƒ‡ã‚£ã‚¿æœ¬ä½“ã®æç”»å¹…ï¼ˆRect.widthï¼‰ã‚’å–å¾—ã™ã‚‹é–¢æ•°
pub fn get_editor_area_width(area: Rect) -> u16 {
    // left_block, right_block, ä½™ç™½ãªã©ã‚’è€ƒæ…®ã—ã¦ã‚¨ãƒ‡ã‚£ã‚¿æœ¬ä½“ã®å¹…ã‚’è¨ˆç®—
    // ã“ã“ã§ã¯ä»®ã«ã€å…¨ä½“ã‚¨ãƒªã‚¢ã‹ã‚‰left_block(6)ã¨right_block(3)ã‚’å¼•ã„ãŸå¹…ã¨ã™ã‚‹
    // å¿…è¦ã«å¿œã˜ã¦æ­£ç¢ºãªå€¤ã«èª¿æ•´ã—ã¦ãã ã•ã„
    area.width.saturating_sub(6 + 3)
}

/// Left Block ã‚’æç”»ã—ã¾ã™ã€‚è¡Œç•ªå·ã¨å·®åˆ†ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
pub fn render_left_block(f: &mut Frame, area: Rect, app: &App) {
    let mut lines_to_display: Vec<Line> = Vec::new();
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    // æŠ˜è¿”ã—ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ: ã‚¨ãƒ‡ã‚£ã‚¿æœ¬ä½“ã®wrapå¹…ã§visual_linesã‚’å–å¾—
    let editor_area_width = get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX // wrapã—ãªã„å ´åˆã¯éå¸¸ã«å¤§ããªå€¤
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let total_visual_lines = visual_lines.len();
    let start = app.editor.scroll_offset_y as usize;
    let end = (start + area.height as usize).min(total_visual_lines);
    let visible_lines = &visual_lines[start..end];

    // --- ä¿®æ­£: startã¾ã§ã«ä½•å€‹ã®è«–ç†è¡ŒãŒã‚ã£ãŸã‹ã‚’æ•°ãˆã‚‹ ---
    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®å…ˆé ­ visual line ãŒå±ã™ã‚‹è«–ç†è¡Œç•ªå·ã‚’è¨ˆç®—
    let mut logical_line_counter = 1;
    if start > 0 {
        // startã¾ã§ã®visual_linesã§wrap_idx==0ã®æ•°ã‚’æ•°ãˆã‚‹
        logical_line_counter += visual_lines[..start]
            .iter()
            .filter(|(_, wrap_idx, _)| *wrap_idx == 0)
            .count();
    }
    // æŠ˜è¿”ã—1è¡Œç›®ã”ã¨ã«è«–ç†è¡Œç•ªå·ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦è¡¨ç¤ºã—ã€æŠ˜è¿”ã—2è¡Œç›®ä»¥é™ã¯ç©ºç™½ã«ã™ã‚‹
    for (buf_idx, wrap_idx, _line_str) in visible_lines.iter() {
        if *wrap_idx == 0 {
            // è«–ç†è¡Œã®å…ˆé ­ visual line ã®ã¿è¡Œç•ªå·ã‚’è¡¨ç¤º
            let line_number = logical_line_counter.to_string();
            let line_status = app.line_statuses.get(*buf_idx).copied().unwrap_or(LineStatus::Unchanged);
            let diff_symbol_style = match line_status {
                LineStatus::Modified => Style::default().fg(Color::Yellow).add_modifier(ratatui::style::Modifier::BOLD),
                LineStatus::Added => Style::default().fg(Color::Green).add_modifier(ratatui::style::Modifier::BOLD),
                LineStatus::Unchanged => Style::default().fg(Color::DarkGray),
            };
            let diff_symbol = match line_status {
                LineStatus::Modified => "~",
                LineStatus::Added => "+",
                LineStatus::Unchanged => " ",
            };
            let line_num_span = Span::styled(format!("{:>4}", line_number), theme_fg);
            let diff_span = Span::styled(format!("{} ", diff_symbol), diff_symbol_style);
            lines_to_display.push(Line::from(vec![line_num_span, diff_span]));
            logical_line_counter += 1;
        } else {
            // æŠ˜è¿”ã—éƒ¨åˆ†ã«ã¯è¡Œç•ªå·ãƒ»å·®åˆ†ã¨ã‚‚ç©ºç™½
            let line_num_span = Span::styled("    ", Style::default().fg(Color::DarkGray));
            let diff_span = Span::styled("  ", Style::default().fg(Color::DarkGray));
            lines_to_display.push(Line::from(vec![line_num_span, diff_span]));
        }
    }
    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã•ã«æº€ãŸãªã„å ´åˆã¯ç©ºè¡Œã§åŸ‹ã‚ã‚‹
    while lines_to_display.len() < area.height as usize {
        lines_to_display.push(Line::from(vec![Span::styled(
            "      ",
            Style::default().fg(Color::DarkGray),
        )]));
    }

    let block = Block::default()
        .borders(Borders::RIGHT)
        .style(Style::default().bg(theme_bg));
    let paragraph = Paragraph::new(lines_to_display)
        .block(block)
        .alignment(Alignment::Right);
    f.render_widget(paragraph, area);
}
===========
===========src/components/message_display.rs
// src/components/message_display.rs

use crate::app::{App, MessageType}; // Appã¨MessageTypeæ§‹é€ ä½“ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
};
use std::time::Duration; // Durationã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ï¼ˆé€šçŸ¥ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰
pub fn render_message_display(f: &mut Frame, area: Rect, app: &App) {
    const MESSAGE_LIFETIME_SECS: u64 = 3; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºæœŸé–“ï¼ˆç§’ï¼‰

    // ç¾åœ¨æ™‚åˆ»ã‹ã‚‰ã€è¡¨ç¤ºæœŸé–“å†…ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    let now = std::time::Instant::now();
    let mut visible_messages: Vec<Line> = app
        .messages
        .iter()
        .filter(|(_, _, timestamp)| {
            now.duration_since(*timestamp) < Duration::from_secs(MESSAGE_LIFETIME_SECS)
        })
        .map(|(msg_type, msg_content, _)| {
            let style = match msg_type {
                MessageType::Info => Style::default().fg(Color::Yellow), // æƒ…å ±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é»„è‰²
                MessageType::Error => Style::default().fg(Color::Red),   // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯èµ¤è‰²
            };
            Line::from(msg_content.clone()).style(style)
        })
        .collect();

    // æœ€æ–°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒä¸‹ã«æ¥ã‚‹ã‚ˆã†ã«é€†é †ã«ä¸¦ã¹æ›¿ãˆï¼ˆç”»é¢ä¸‹ã‹ã‚‰ä¸Šã¸è¡¨ç¤ºã™ã‚‹ãŸã‚ï¼‰
    visible_messages.reverse();

    // ui.rs ã§æ—¢ã«è¡¨ç¤ºã‚¨ãƒªã‚¢ã®é«˜ã•ãŒèª¿æ•´ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã®truncateã¯ä¸è¦ã§ã™ã€‚
    // Paragraphã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã¯ã€æ¸¡ã•ã‚ŒãŸTextã®è¡Œæ•°ãŒarea.heightã‚’è¶…ãˆã‚‹å ´åˆã€è‡ªå‹•çš„ã«ã‚¯ãƒªãƒƒãƒ—ã—ã¾ã™ã€‚

    // è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãªã„å ´åˆã€ã¾ãŸã¯è¡¨ç¤ºã‚¨ãƒªã‚¢ã®é«˜ã•ãŒ0ã®å ´åˆã¯æç”»ã—ãªã„
    if visible_messages.is_empty() || area.height == 0 {
        return;
    }

    let block = Block::default()
        .borders(Borders::NONE) // å¢ƒç•Œç·š
        .style(Style::default().bg(Color::DarkGray)); // æš—ã„èƒŒæ™¯è‰²ã§é€šçŸ¥æ„Ÿã‚’å‡ºã™

    let paragraph = Paragraph::new(visible_messages)
        .block(block)
        .alignment(ratatui::layout::Alignment::Right) // å³å¯„ã›
        .scroll((0, 0)); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ã•ã›ãªã„

    f.render_widget(paragraph, area);
}
===========
===========src/components/top_bar.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Modifier, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
}; // Appæ§‹é€ ä½“ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/// Top Bar ã‚’æç”»ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«åã€è¨€èªã€å¤‰æ›´çŠ¶æ…‹ãªã©ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
pub fn render_top_bar(f: &mut Frame, area: Rect, app: &App) {
    let filename = app
        .target_path
        .as_ref()
        .and_then(|p| p.file_name())
        .and_then(|s| s.to_str())
        .unwrap_or("untitled");

    let modified_indicator = if app.has_unsaved_changes() { "*" } else { "" };

    let current_language = &app.current_syntax_name;
    let current_theme = &app.highlighter.current_theme_name;

    // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã¨å‰æ™¯è‰²ã‚’å–å¾—
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    let text_content = format!(
        " {} {}{} | Language: {} | Theme: {} ",
        app.editor.search_query, // æ¤œç´¢ã‚¯ã‚¨ãƒªãŒã‚ã‚Œã°è¡¨ç¤º
        filename,
        modified_indicator,
        current_language,
        current_theme
    );

    let paragraph = Paragraph::new(Line::from(text_content))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(theme_bg)),
        ) // ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã‚’é©ç”¨
        .alignment(Alignment::Left) // å·¦å¯„ã›
        .style(Style::default().fg(theme_fg).add_modifier(Modifier::BOLD)); // ãƒ†ãƒ¼ãƒã®å‰æ™¯è‰²ã‚’é©ç”¨

    f.render_widget(paragraph, area);
}
===========
===========src/components/search.rs
===========
===========src/components/middle_block.rs
pub mod editor_block;
pub mod left_block;
pub mod right_block;
===========
===========src/app.rs
// src/app.rs
pub mod cursor;
pub mod editor;
pub mod features;
pub mod msg;
pub use crate::app::features::syntax::Highlighter;
pub use crate::components::popup::{ExitPopupOption, ExitPopupResult, ExitPopupState};
pub use crate::config::{Config, load_or_create_config, save_config};
use crate::{emsg, msg};
use editor::Editor;
use std::env;
use std::fs;
use std::io;
use std::path::PathBuf;
use std::time::{Duration, Instant}; // Configé–¢é€£ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/// UIã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç¨®é¡ã‚’å®šç¾©ã—ã¾ã™ã€‚
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MessageType {
    Info,
    Error,
}

/// å„è¡Œã®å·®åˆ†çŠ¶æ…‹ã‚’å®šç¾©ã—ã¾ã™ã€‚
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LineStatus {
    Unchanged,
    Modified,
    Added,
}

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†çµæœã‚’å®šç¾©ã—ã¾ã™ã€‚
#[derive(Debug, PartialEq, Eq)]
pub enum AppControlFlow {
    Continue,              // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€šå¸¸é€šã‚Šç¶šè¡Œ
    Exit,                  // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†
    TriggerSaveAndExit,    // ä¿å­˜æ“ä½œã‚’è¡Œã„ã€ãã®å¾Œçµ‚äº†
    TriggerDiscardAndExit, // å¤‰æ›´ã‚’ç ´æ£„ã—ã€ãã®å¾Œçµ‚äº†
    ShowExitPopup,         // çµ‚äº†ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤ºã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’å¾…ã¤
}

pub enum InputOverlay {
    None,
    Search { query: String, cursor: usize },
    Replace { query: String, replace: String, cursor: usize, focus_replace: bool },
    Suggest { prefix: String, suggestions: Vec<String>, selected: usize },
}

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã®çŠ¶æ…‹ã‚’ç®¡ç†ã—ã¾ã™ã€‚
pub struct App {
    pub editor: Editor,
    pub target_path: Option<PathBuf>,
    pub temp_path: Option<PathBuf>,
    pub clipboard: Option<String>,
    pub messages: Vec<(MessageType, String, Instant)>,
    pub original_buffer: String,
    pub word_wrap_enabled: bool,
    pub line_statuses: Vec<LineStatus>,
    pub exit_popup_state: Option<ExitPopupState>,
    pub highlighter: Highlighter,
    pub current_syntax_name: String,
    pub config: Config, // è¿½åŠ : ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š
    pub input_overlay: InputOverlay,
}

impl Default for App {
    fn default() -> Self {
        // configã‚’å…ˆã«ãƒ­ãƒ¼ãƒ‰ã—ã¦ãŠã
        let config = load_or_create_config();
        let mut highlighter = Highlighter::new();
        // ã‚³ãƒ³ãƒ•ã‚£ã‚°ã‹ã‚‰ãƒ†ãƒ¼ãƒã‚’åˆæœŸè¨­å®š
        highlighter.set_theme(&config.color_theme);

        Self {
            editor: Editor::new(String::new()),
            target_path: None,
            temp_path: None,
            clipboard: None,
            messages: Vec::new(),
            original_buffer: String::new(),
            word_wrap_enabled: false,
            line_statuses: Vec::new(),
            exit_popup_state: None,
            highlighter, // åˆæœŸåŒ–æ¸ˆã¿Highlighterã‚’ä½¿ç”¨
            current_syntax_name: "Plain Text".to_string(),
            config, // åˆæœŸåŒ–æ¸ˆã¿configã‚’ä½¿ç”¨
            input_overlay: InputOverlay::None,
        }
    }
}

/// AppãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹éš›ã«ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã®Dropå®Ÿè£…
impl Drop for App {
    fn drop(&mut self) {
        if let Some(path) = &self.temp_path {
            if path.exists() {
                if let Err(e) = fs::remove_file(path) {
                    emsg!(
                        self,
                        "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}",
                        path,
                        e
                    );
                } else {
                    msg!(self, "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚", path);
                }
            }
        }
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã«è¨­å®šã‚’ä¿å­˜
        if let Err(e) = save_config(&self.config) {
            emsg!(self, "Error saving config on exit: {}", e);
        }
    }
}

impl App {
    /// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
    pub fn init() -> Self {
        let mut app = Self::default(); // default()ã§configã¨highlighterãŒåˆæœŸåŒ–ã•ã‚Œã‚‹

        let args: Vec<String> = env::args().collect();
        let file_path_str_opt = args.get(1);

        if let Some(file_path_str) = file_path_str_opt {
            let original_path = PathBuf::from(file_path_str);
            app.target_path = Some(original_path.clone());

            let temp_filename = format!(
                ".{}.inedit",
                original_path
                    .file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or("untitled")
            );
            let temp_file = PathBuf::from(".");
            let temp_path = original_path
                .parent()
                .unwrap_or(temp_file.as_path())
                .join(temp_filename);
            app.temp_path = Some(temp_path.clone());

            msg!(app, "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: {:?}", original_path);
            msg!(app, "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: {:?}", temp_path);
            msg!(
                app,
                "ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡Œæ•°: {}",
                app.editor.buffer.lines().collect::<Vec<&str>>().len()
            );

            // ã¾ãšä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã‚’è©¦ã¿ã‚‹
            if temp_path.exists() {
                match app.editor.load_from_file(&temp_path) {
                    Ok(_) => {
                        msg!(
                            app,
                            "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‹ã‚‰æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚",
                            temp_path
                        );
                        app.original_buffer = app.editor.buffer.clone();
                    }
                    Err(e) => {
                        emsg!(
                            app,
                            "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}ã€‚å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã«æˆ»ã‚Šã¾ã™ã€‚",
                            temp_path,
                            e
                        );
                        if original_path.exists() {
                            match app.editor.load_from_file(&original_path) {
                                Ok(_) => {
                                    msg!(
                                        app,
                                        "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚",
                                        original_path
                                    );
                                    app.original_buffer = app.editor.buffer.clone();
                                    if let Err(e) = app.editor.save_to_file(&temp_path) {
                                        emsg!(
                                            app,
                                            "è­¦å‘Š: åˆæœŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã«æ›¸ãè¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ: {}",
                                            temp_path,
                                            e
                                        );
                                    }
                                }
                                Err(e) => {
                                    emsg!(
                                        app,
                                        "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}ã€‚ç©ºã®ãƒãƒƒãƒ•ã‚¡ã§é–‹å§‹ã—ã¾ã™ã€‚",
                                        original_path,
                                        e
                                    );
                                    if let Err(e) = fs::write(&temp_path, "") {
                                        emsg!(
                                            app,
                                            "è­¦å‘Š: ç©ºã®ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: {}",
                                            temp_path,
                                            e
                                        );
                                    }
                                }
                            }
                        } else {
                            msg!(
                                app,
                                "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {:?}ã€‚æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒãƒ•ã‚¡ã¨ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚",
                                file_path_str
                            );
                            if let Err(e) = fs::write(&temp_path, "") {
                                emsg!(
                                    app,
                                    "è­¦å‘Š: ç©ºã®ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                    }
                }
            } else {
                // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è©¦ã™
                if original_path.exists() {
                    match app.editor.load_from_file(&original_path) {
                        Ok(_) => {
                            msg!(
                                app,
                                "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚",
                                original_path
                            );
                            app.original_buffer = app.editor.buffer.clone();
                            if let Err(e) = app.editor.save_to_file(&temp_path) {
                                emsg!(
                                    app,
                                    "è­¦å‘Š: åˆæœŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã«æ›¸ãè¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                        Err(e) => {
                            emsg!(
                                app,
                                "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}ã€‚ç©ºã®ãƒãƒƒãƒ•ã‚¡ã§é–‹å§‹ã—ã¾ã™ã€‚",
                                original_path,
                                e
                            );
                            if let Err(e) = fs::write(&temp_path, "") {
                                emsg!(
                                    app,
                                    "è­¦å‘Š: ç©ºã®ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                    }
                } else {
                    msg!(
                        app,
                        "å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {:?}ã€‚æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒãƒ•ã‚¡ã¨ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚",
                        file_path_str
                    );
                    if let Err(e) = fs::write(&temp_path, "") {
                        emsg!(
                            app,
                            "è­¦å‘Š: ç©ºã®ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ« {:?} ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: {}",
                            temp_path,
                            e
                        );
                    }
                }
            }
        } else {
            msg!(
                app,
                "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç©ºã®ãƒãƒƒãƒ•ã‚¡ï¼ˆãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼‰ã§é–‹å§‹ã—ã¾ã™ã€‚ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä½œæˆã•ã‚Œã¾ã›ã‚“ã€‚"
            );
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã¨ãƒ‘ã‚¹ã«åŸºã¥ã„ã¦ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æ±ºå®š
        let first_lines: String = app
            .editor
            .buffer
            .lines()
            .take(5)
            .collect::<Vec<&str>>()
            .join("\n");
        let syntax = app
            .highlighter
            .get_syntax_for_file(app.target_path.as_deref(), &first_lines);
        app.current_syntax_name = syntax.name.clone();
        msg!(app, "è¨€èª: {}", app.current_syntax_name);

        app.calculate_diff_status();
        app
    }

    /// ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã™ã€‚å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
    pub fn save_current_file(&mut self) -> io::Result<()> {
        if let Some(original_path) = &self.target_path {
            self.editor.save_to_file(original_path)?;
            msg!(self, "ãƒ•ã‚¡ã‚¤ãƒ«ã¯ {:?} ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚", original_path);
            self.original_buffer = self.editor.buffer.clone();
            self.calculate_diff_status();

            Ok(())
        } else {
            emsg!(
                self,
                "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã€Œåå‰ã‚’ä»˜ã‘ã¦ä¿å­˜ã€æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"
            );
            Err(io::Error::other(
                "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã€Œåå‰ã‚’ä»˜ã‘ã¦ä¿å­˜ã€æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚",
            ))
        }
    }

    /// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã«æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¾ã™ã€‚
    pub fn add_message(&mut self, message_type: MessageType, msg: String) {
        self.messages.push((message_type, msg, Instant::now()));
    }

    /// ç¾åœ¨ã®ãƒãƒƒãƒ•ã‚¡ã¨ã‚ªãƒªã‚¸ãƒŠãƒ«ãƒãƒƒãƒ•ã‚¡ã‚’æ¯”è¼ƒã—ã€å„è¡Œã®å·®åˆ†çŠ¶æ…‹ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
    pub fn calculate_diff_status(&mut self) {
        self.line_statuses.clear();
        let original_lines: Vec<&str> = self.original_buffer.lines().collect();
        let current_lines: Vec<&str> = self.editor.buffer.lines().collect();

        for (i, current_line) in current_lines.iter().enumerate() {
            if let Some(original_line) = original_lines.get(i) {
                if current_line == original_line {
                    self.line_statuses.push(LineStatus::Unchanged);
                } else {
                    self.line_statuses.push(LineStatus::Modified);
                }
            } else {
                self.line_statuses.push(LineStatus::Added);
            }
        }
    }

    pub fn get_visible_message_count(&self) -> u16 {
        const MESSAGE_LIFETIME_SECS: u64 = 3;
        let now = Instant::now();
        self.messages
            .iter()
            .filter(|(_, _, timestamp)| {
                now.duration_since(*timestamp) < Duration::from_secs(MESSAGE_LIFETIME_SECS)
            })
            .count() as u16
    }

    /// æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
    pub fn has_unsaved_changes(&self) -> bool {
        self.editor.buffer != self.original_buffer
    }

    /// çµ‚äº†ã‚’è©¦ã¿ã¾ã™ã€‚æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚‹å ´åˆã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤ºã™ã‚‹çŠ¶æ…‹ã«è¨­å®šã—ã¾ã™ã€‚
    pub fn trigger_exit_popup_if_needed(&mut self) {
        if self.has_unsaved_changes() {
            self.exit_popup_state = Some(ExitPopupState::default());
        }
    }

    /// çµ‚äº†ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã—ã¾ã™ã€‚
    pub fn handle_exit_popup_key(
        &mut self,
        key_event: &crossterm::event::KeyEvent,
    ) -> ExitPopupResult {
        if let Some(state) = &mut self.exit_popup_state {
            match key_event.code {
                crossterm::event::KeyCode::Up => {
                    state.previous();
                    ExitPopupResult::None
                }
                crossterm::event::KeyCode::Down => {
                    state.next();
                    ExitPopupResult::None
                }
                crossterm::event::KeyCode::Enter => {
                    let result = match state.selected_option {
                        ExitPopupOption::SaveAndExit => ExitPopupResult::SaveAndExit,
                        ExitPopupOption::DiscardAndExit => ExitPopupResult::DiscardAndExit,
                        ExitPopupOption::Cancel => ExitPopupResult::Cancel,
                    };
                    self.exit_popup_state = None;
                    result
                }
                crossterm::event::KeyCode::Char('s') | crossterm::event::KeyCode::Char('S') => {
                    self.exit_popup_state = None;
                    ExitPopupResult::SaveAndExit
                }
                crossterm::event::KeyCode::Char('d') | crossterm::event::KeyCode::Char('D') => {
                    self.exit_popup_state = None;
                    ExitPopupResult::DiscardAndExit
                }
                crossterm::event::KeyCode::Char('c')
                | crossterm::event::KeyCode::Char('C')
                | crossterm::event::KeyCode::Esc => {
                    self.exit_popup_state = None;
                    ExitPopupResult::Cancel
                }
                _ => ExitPopupResult::None,
            }
        } else {
            ExitPopupResult::None
        }
    }

    /// Highlighterã®ãƒ†ãƒ¼ãƒã‚’å¤‰æ›´ã—ã¾ã™ã€‚
    pub fn set_highlighter_theme(&mut self, theme_name: &str) {
        if self.highlighter.set_theme(theme_name) {
            self.config.color_theme = theme_name.to_string(); // Configã‚‚æ›´æ–°
            msg!(self, "ãƒ†ãƒ¼ãƒã‚’ '{}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚", theme_name);
        } else {
            emsg!(self, "ãƒ†ãƒ¼ãƒ '{}' ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚", theme_name);
        }
    }
}
===========
===========src/config.rs
//! ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®šï¼ˆã‚«ãƒ©ãƒ¼ãƒ†ãƒ¼ãƒã€ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ãªã©ï¼‰ã‚’ç®¡ç†ã—ã¾ã™ã€‚
//! è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ä½œæˆã—ã€å­˜åœ¨ã™ã‚‹å ´åˆã¯èª­ã¿è¾¼ã¿ã¾ã™ã€‚

use crossterm::event::{KeyCode, KeyModifiers};
use directories::ProjectDirs; // ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹è§£æ±ºã®ãŸã‚
use serde::{Deserialize, Serialize};
use std::{fs, io, path::PathBuf}; // KeyCodeã¨KeyModifiersã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

const CONFIG_FILE_NAME: &str = "config.yaml";

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã®ã‚³ãƒ³ãƒ•ã‚£ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Config {
    pub color_theme: String,
    pub key_bindings: KeyBindings,
}

/// ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ã®è¨­å®š
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KeyBindings {
    // çµ‚äº†
    pub exit_1: KeyEventConfig, // Ctrl+Q
    pub exit_2: KeyEventConfig, // Ctrl+W
    pub exit_3: KeyEventConfig, // Esc

    // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
    pub save_file: KeyEventConfig, // Ctrl+S
    pub open_file: KeyEventConfig, // Ctrl+O (æœªå®Ÿè£…ã ãŒäºˆç´„)

    // ç·¨é›†æ“ä½œ
    pub copy: KeyEventConfig,                 // Ctrl+C
    pub cut: KeyEventConfig,                  // Ctrl+X
    pub paste: KeyEventConfig,                // Ctrl+V
    pub select_all: KeyEventConfig,           // Ctrl+A
    pub insert_newline: KeyEventConfig,       // Enter
    pub insert_tab: KeyEventConfig,           // Tab
    pub delete_previous_char: KeyEventConfig, // Backspace
    pub delete_current_char: KeyEventConfig,  // Delete

    // Undo/Redo
    pub undo: KeyEventConfig, // Ctrl+Z
    pub redo: KeyEventConfig, // Ctrl+Y

    // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
    pub move_left: KeyEventConfig,
    pub move_right: KeyEventConfig,
    pub move_up: KeyEventConfig,
    pub move_down: KeyEventConfig,
    pub move_line_start: KeyEventConfig,     // Home
    pub move_line_end: KeyEventConfig,       // End
    pub move_document_start: KeyEventConfig, // Ctrl+Home (ã¾ãŸã¯é¡ä¼¼)
    pub move_document_end: KeyEventConfig,   // Ctrl+End (ã¾ãŸã¯é¡ä¼¼)

    // æ©Ÿèƒ½ãƒˆã‚°ãƒ«
    pub toggle_word_wrap: KeyEventConfig, // Alt+Z
}

/// ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º/ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ãªå½¢å¼ã§è¡¨ç¾
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KeyEventConfig {
    pub code: String,           // KeyCodeã‚’æ–‡å­—åˆ—ã§ä¿å­˜ (ä¾‹: "Char(q)", "Esc", "Left")
    pub modifiers: Vec<String>, // KeyModifiersã‚’æ–‡å­—åˆ—ã®Vecã§ä¿å­˜ (ä¾‹: ["Control", "Shift"])
}

impl KeyEventConfig {
    /// `crossterm::event::KeyCode`ã¨`crossterm::event::KeyModifiers`ã‹ã‚‰`KeyEventConfig`ã‚’ç”Ÿæˆ
    pub fn from_key_event(code: KeyCode, modifiers: KeyModifiers) -> Self {
        let code_str = format!("{:?}", code);
        let mut modifiers_vec = Vec::new();
        if modifiers.contains(KeyModifiers::CONTROL) {
            modifiers_vec.push("Control".to_string());
        }
        if modifiers.contains(KeyModifiers::ALT) {
            modifiers_vec.push("Alt".to_string());
        }
        if modifiers.contains(KeyModifiers::SHIFT) {
            modifiers_vec.push("Shift".to_string());
        }
        KeyEventConfig {
            code: code_str,
            modifiers: modifiers_vec,
        }
    }

    /// `KeyEventConfig`ãŒæŒ‡å®šã•ã‚ŒãŸ`crossterm::event::KeyEvent`ã¨ä¸€è‡´ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    pub fn matches(&self, key_event: &crossterm::event::KeyEvent) -> bool {
        // KeyCodeã®æ¯”è¼ƒ
        let self_code_str = &self.code;
        let event_code_str = format!("{:?}", key_event.code);
        if self_code_str != &event_code_str {
            return false;
        }

        // --- ä¿®æ­£: self.modifiersãŒç©ºãªã‚‰ã€ä¿®é£¾ã‚­ãƒ¼å•ã‚ãšãƒãƒƒãƒã™ã‚‹ ---
        if self.modifiers.is_empty() {
            return true;
        }

        // KeyModifiersã®æ¯”è¼ƒï¼ˆself.modifiersãŒå…¨ã¦event_modifiers_vecã«å«ã¾ã‚Œã¦ã„ã‚Œã°OKï¼‰
        let mut event_modifiers_vec = Vec::new();
        if key_event.modifiers.contains(KeyModifiers::CONTROL) {
            event_modifiers_vec.push("Control");
        }
        if key_event.modifiers.contains(KeyModifiers::ALT) {
            event_modifiers_vec.push("Alt");
        }
        if key_event.modifiers.contains(KeyModifiers::SHIFT) {
            event_modifiers_vec.push("Shift");
        }

        self.modifiers
            .iter()
            .all(|m| event_modifiers_vec.contains(&m.as_str()))
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            color_theme: "Solarized (dark)".to_string(), // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ãƒ¼ãƒå
            key_bindings: KeyBindings::default(),
        }
    }
}

impl Default for KeyBindings {
    fn default() -> Self {
        KeyBindings {
            exit_1: KeyEventConfig::from_key_event(KeyCode::Char('q'), KeyModifiers::CONTROL),
            exit_2: KeyEventConfig::from_key_event(KeyCode::Char('w'), KeyModifiers::CONTROL),
            exit_3: KeyEventConfig::from_key_event(KeyCode::Esc, KeyModifiers::NONE),

            save_file: KeyEventConfig::from_key_event(KeyCode::Char('s'), KeyModifiers::CONTROL),
            open_file: KeyEventConfig::from_key_event(KeyCode::Char('o'), KeyModifiers::CONTROL),

            copy: KeyEventConfig::from_key_event(KeyCode::Char('c'), KeyModifiers::CONTROL),
            cut: KeyEventConfig::from_key_event(KeyCode::Char('x'), KeyModifiers::CONTROL),
            paste: KeyEventConfig::from_key_event(KeyCode::Char('v'), KeyModifiers::CONTROL),
            select_all: KeyEventConfig::from_key_event(KeyCode::Char('a'), KeyModifiers::CONTROL),
            insert_newline: KeyEventConfig::from_key_event(KeyCode::Enter, KeyModifiers::NONE),
            insert_tab: KeyEventConfig::from_key_event(KeyCode::Tab, KeyModifiers::NONE),
            delete_previous_char: KeyEventConfig::from_key_event(
                KeyCode::Backspace,
                KeyModifiers::NONE,
            ),
            delete_current_char: KeyEventConfig::from_key_event(
                KeyCode::Delete,
                KeyModifiers::NONE,
            ),

            // Undo/Redo
            undo: KeyEventConfig::from_key_event(KeyCode::Char('z'), KeyModifiers::CONTROL),
            redo: KeyEventConfig::from_key_event(KeyCode::Char('y'), KeyModifiers::CONTROL),

            move_left: KeyEventConfig::from_key_event(KeyCode::Left, KeyModifiers::NONE),
            move_right: KeyEventConfig::from_key_event(KeyCode::Right, KeyModifiers::NONE),
            move_up: KeyEventConfig::from_key_event(KeyCode::Up, KeyModifiers::NONE),
            move_down: KeyEventConfig::from_key_event(KeyCode::Down, KeyModifiers::NONE),
            move_line_start: KeyEventConfig::from_key_event(KeyCode::Home, KeyModifiers::NONE),
            move_line_end: KeyEventConfig::from_key_event(KeyCode::End, KeyModifiers::NONE),
            move_document_start: KeyEventConfig::from_key_event(
                KeyCode::Home,
                KeyModifiers::CONTROL,
            ), // Ctrl+Home
            move_document_end: KeyEventConfig::from_key_event(KeyCode::End, KeyModifiers::CONTROL), // Ctrl+End

            toggle_word_wrap: KeyEventConfig::from_key_event(KeyCode::Char('z'), KeyModifiers::ALT),
        }
    }
}

/// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’å–å¾—ã—ã¾ã™ã€‚
/// ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€`directories`ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
fn get_config_path() -> Option<PathBuf> {
    if let Some(proj_dirs) = ProjectDirs::from("com", "inedit", "Inedit") {
        let config_dir = proj_dirs.config_dir();
        if !config_dir.exists() {
            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆã‚’è©¦ã¿ã‚‹
            if let Err(_e) = fs::create_dir_all(config_dir) {
                // eprintln!("Error creating config directory {:?}: {}", config_dir, e);
                return None;
            }
        }
        Some(config_dir.join(CONFIG_FILE_NAME))
    } else {
        // eprintln!("Could not determine config directory.");
        None
    }
}

/// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ä½œæˆã—ã¾ã™ã€‚
pub fn load_or_create_config() -> Config {
    if let Some(config_path) = get_config_path() {
        if config_path.exists() {
            match fs::read_to_string(&config_path) {
                Ok(content) => match serde_yaml::from_str(&content) {
                    Ok(config) => {
                        // eprintln!("Config loaded from {:?}", config_path);
                        return config;
                    }
                    Err(_e) => {
                        // eprintln!("Error parsing config file {:?}: {}", config_path, e);
                        // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã—ã€ä¸Šæ›¸ãä¿å­˜
                        let default_config = Config::default();
                        if let Err(_e) = save_config(&default_config) {
                            // eprintln!("Error saving default config: {}", e);
                        }
                        return default_config;
                    }
                },
                Err(_e) => {
                    // eprintln!("Error reading config file {:?}: {}", config_path, e);
                    // èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ã®å ´åˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã—ã€ä¸Šæ›¸ãä¿å­˜
                    let default_config = Config::default();
                    if let Err(_e) = save_config(&default_config) {
                        // eprintln!("Error saving default config: {}", e);
                    }
                    return default_config;
                }
            }
        } else {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ä½œæˆ
            let default_config = Config::default();
            if let Err(_e) = save_config(&default_config) {
                // eprintln!("Error saving default config: {}", e);
            }
            // eprintln!("Created default config at {:?}", config_path);
            return default_config;
        }
    }
    // ã‚³ãƒ³ãƒ•ã‚£ã‚°ãƒ‘ã‚¹ãŒå–å¾—ã§ããªã„å ´åˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã™
    // eprintln!("Could not get config path, using default config.");
    Config::default()
}

/// è¨­å®šã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã—ã¾ã™ã€‚
pub fn save_config(config: &Config) -> io::Result<()> {
    if let Some(config_path) = get_config_path() {
        let yaml_content = serde_yaml::to_string(config).map_err(|e| {
            io::Error::other(
                format!("Failed to serialize config: {}", e),
            )
        })?;
        fs::write(&config_path, yaml_content)?;
        // eprintln!("Config saved to {:?}", config_path);
        Ok(())
    } else {
        Err(io::Error::other(
            "Could not determine config path for saving.",
        ))
    }
}
===========
===========src/app/cursor.rs
// src/app/cursor.rs

/// ã‚«ãƒ¼ã‚½ãƒ«ã®è«–ç†çš„ãªä½ç½®ã¨é¸æŠç¯„å›²ã‚’ç®¡ç†ã—ã¾ã™ã€‚
/// ã“ã®æ§‹é€ ä½“ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚„ãã®å¢ƒç•Œã«é–¢ã™ã‚‹çŸ¥è­˜ã‚’æŒã¡ã¾ã›ã‚“ã€‚
/// å®Ÿéš›ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®èª¿æ•´ï¼ˆãƒãƒƒãƒ•ã‚¡å¢ƒç•Œå†…ã¸ã®ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰ã¯Editorå´ã§è¡Œã†ã¹ãã§ã™ã€‚
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub struct Cursor {
    pub x: u16,                              // åˆ—ä½ç½® (0-indexed, æ–‡å­—å˜ä½)
    pub y: u16,                              // è¡Œä½ç½® (0-indexed)
    pub selection_start: Option<(u16, u16)>, // é¸æŠç¯„å›²ã®é–‹å§‹ä½ç½® (x, y)
}

impl Cursor {
    /// æ–°ã—ã„ã‚«ãƒ¼ã‚½ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚
    pub fn new(x: u16, y: u16) -> Self {
        Self {
            x,
            y,
            selection_start: None,
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°ã—ã¾ã™ã€‚
    /// ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€`Editor`ãŒå¢ƒç•Œãƒã‚§ãƒƒã‚¯ã‚’è¡Œã£ãŸå¾Œã«ã€æœ€çµ‚çš„ãªã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’
    /// è¨­å®šã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã™ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚
    ///
    /// `extend_selection`ãŒ`true`ã®å ´åˆã€ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’åŸºæº–ã«é¸æŠç¯„å›²ã‚’æ‹¡å¼µã—ã¾ã™ã€‚
    /// ã¾ã é¸æŠãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã“ã®å‘¼ã³å‡ºã—ã®å‰ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ãŒé¸æŠé–‹å§‹ç‚¹ã¨ãªã‚Šã¾ã™ã€‚
    /// `false`ã®å ´åˆã€æ—¢å­˜ã®é¸æŠç¯„å›²ã¯ã‚¯ãƒªã‚¢ã•ã‚Œã¾ã™ã€‚
    pub fn update_position(&mut self, new_x: u16, new_y: u16, extend_selection: bool) {
        if !extend_selection {
            // é¸æŠã‚’æ‹¡å¼µã—ãªã„å ´åˆã€ç¾åœ¨ã®é¸æŠã‚’ã‚¯ãƒªã‚¢
            self.clear_selection();
        } else if self.selection_start.is_none() {
            // é¸æŠãƒ¢ãƒ¼ãƒ‰ã§ã¾ã é¸æŠãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆã€ç¾åœ¨ã®ï¼ˆç§»å‹•å‰ã®ï¼‰ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’é¸æŠé–‹å§‹ç‚¹ã¨ã™ã‚‹
            // ä¿®æ­£ç®‡æ‰€: ã“ã“ã§ new_x, new_y ã§ã¯ãªã self.x, self.y ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
            self.selection_start = Some((self.x, self.y));
        }
        self.x = new_x;
        self.y = new_y;
    }

    /// ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å–å¾—ã—ã¾ã™ã€‚
    pub fn get_current_pos(&self) -> (u16, u16) {
        (self.x, self.y)
    }

    /// é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚
    pub fn clear_selection(&mut self) {
        self.selection_start = None;
    }

    /// ç¾åœ¨é¸æŠä¸­ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn is_selecting(&self) -> bool {
        self.selection_start.is_some()
    }

    /// é¸æŠç¯„å›²ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€æ­£è¦åŒ–ã•ã‚ŒãŸé–‹å§‹ç‚¹ã¨çµ‚äº†ç‚¹ï¼ˆ(y, x)å½¢å¼ï¼‰ã‚’è¿”ã—ã¾ã™ã€‚
    /// é–‹å§‹ç‚¹ã¨çµ‚äº†ç‚¹ã¯ã€å¸¸ã«è«–ç†çš„ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆé †ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚
    /// ä¾‹: `((start_y, start_x), (end_y, end_x))`
    ///
    /// æ³¨æ„: ã“ã“ã§è¿”ã•ã‚Œã‚‹åº§æ¨™ã¯è«–ç†çš„ãªã‚‚ã®ã§ã‚ã‚Šã€ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
    /// ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã¸ã®å¤‰æ›ã¯Editorå´ã§è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
    pub fn get_normalized_selection_coords(&self) -> Option<((u16, u16), (u16, u16))> {
        if let Some(start_pos) = self.selection_start {
            // selection_startã¯(x, y)å½¢å¼ãªã®ã§ã€(y, x)ã«å¤‰æ›
            let selection_start_y_x = (start_pos.1, start_pos.0);
            let current_pos_y_x = (self.y, self.x);

            // é¸æŠé–‹å§‹ç‚¹ã¨ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ãŒåŒã˜å ´åˆã¯é¸æŠç¯„å›²ãŒãªã„
            if selection_start_y_x == current_pos_y_x {
                None
            } else {
                let mut points = [selection_start_y_x, current_pos_y_x];
                // yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆã—ã€yãŒåŒã˜å ´åˆã¯xåº§æ¨™ã§ã‚½ãƒ¼ãƒˆ
                points.sort_unstable();
                Some((points[0], points[1]))
            }
        } else {
            None
        }
    }
}

// ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚«ãƒ¼ã‚½ãƒ«ã®ã€Œå¸Œæœ›ã™ã‚‹ã€ç§»å‹•å…ˆã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã§ã™ã€‚
// å®Ÿéš›ã®æœ€çµ‚çš„ãªã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ï¼ˆãƒãƒƒãƒ•ã‚¡å¢ƒç•Œã«åˆã‚ã›ãŸã‚‚ã®ï¼‰ã¯ã€Editorå´ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚
impl Cursor {
    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’1è¡Œä¸‹ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸYåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_next_line_y(&self) -> u16 {
        self.y.saturating_add(1)
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’1è¡Œä¸Šã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸYåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_previous_line_y(&self) -> u16 {
        self.y.saturating_sub(1)
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’1æ–‡å­—å³ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸXåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_next_char_x(&self) -> u16 {
        self.x.saturating_add(1)
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’1æ–‡å­—å·¦ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸXåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_previous_char_x(&self) -> u16 {
        self.x.saturating_sub(1)
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç¾åœ¨ã®è¡Œã®å…ˆé ­ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸXåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_start_of_line_x(&self) -> u16 {
        0
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç¾åœ¨ã®è¡Œã®æœ«å°¾ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸXåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    /// ã“ã‚Œã¯EditorãŒå®Ÿéš›ã®è¡Œã®é•·ã•ã‚’è€ƒæ…®ã—ã¦èª¿æ•´ã™ã‚‹ã€Œãƒãƒ¼ã‚«ãƒ¼ã€ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚
    pub fn get_potential_end_of_line_x(&self) -> u16 {
        u16::MAX // EditorãŒã“ã®å€¤ã‚’ã€Œè¡Œæœ«ã€ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã“ã¨ã‚’æœŸå¾…
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®å…ˆé ­ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸYåº§æ¨™ã¨Xåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_potential_document_start_pos(&self) -> (u16, u16) {
        (0, 0) // (y, x) å½¢å¼
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ«å°¾ã«ç§»å‹•ã—ãŸã¨ä»®å®šã—ãŸYåº§æ¨™ã¨Xåº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚
    /// ã“ã‚Œã‚‚EditorãŒå®Ÿéš›ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è¡Œæ•°ã¨æœ€å¾Œã®è¡Œã®é•·ã•ã‚’è€ƒæ…®ã—ã¦èª¿æ•´ã™ã‚‹ã€Œãƒãƒ¼ã‚«ãƒ¼ã€ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚
    pub fn get_potential_document_end_pos(&self) -> (u16, u16) {
        (u16::MAX, u16::MAX) // (y, x) å½¢å¼ã€‚EditorãŒã“ã®å€¤ã‚’ã€Œãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæœ«å°¾ã€ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã“ã¨ã‚’æœŸå¾…
    }
}
===========
===========src/app/editor.rs
// src/app/editor.rs
pub mod search;
pub mod suggest;
use super::cursor::Cursor;
use arboard::Clipboard; // ã™ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¸ˆã¿
use ratatui::layout::Rect;
use std::fs;
use std::io;
use std::path::Path;
// use unicode_width::UnicodeWidthChar; // unicode-width ã¯ä½¿ç”¨ã—ã¾ã›ã‚“
use ratatui::text::Line as RatatuiLine; // ratatui::text::Line ã‚’ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/// ãƒ†ã‚­ã‚¹ãƒˆãƒãƒƒãƒ•ã‚¡ã¨ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç®¡ç†ã—ã€ç·¨é›†æ“ä½œã‚’æä¾›ã—ã¾ã™ã€‚
#[derive(Default)]
pub struct Editor {
    pub buffer: String,
    pub cursor: Cursor,
    pub search_query: String,
    pub search_matches: Vec<(u16, u16)>, // æ¤œç´¢çµæœã®(y, x)ä½ç½® (æ–‡å­—å˜ä½)
    pub current_search_idx: Option<usize>, // ç¾åœ¨ã®æ¤œç´¢çµæœã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    pub scroll_offset_y: u16,            // å‚ç›´æ–¹å‘ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ (è¡Œå˜ä½)
    pub scroll_offset_x: u16,            // æ°´å¹³æ–¹å‘ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ (æ–‡å­—å˜ä½)
    pub cursor_wrap_idx: usize, // æŠ˜è¿”ã—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
    undo_stack: Vec<String>,
    redo_stack: Vec<String>,
}

impl Editor {
    /// æ–°ã—ã„ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚
    pub fn new(initial_text: String) -> Self {
        Self {
            buffer: initial_text,
            cursor: Cursor::new(0, 0),
            search_query: String::new(),
            search_matches: Vec::new(),
            current_search_idx: None,
            scroll_offset_y: 0, // åˆæœŸã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            scroll_offset_x: 0, // åˆæœŸã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            cursor_wrap_idx: 0, // åˆæœŸå€¤
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
        }
    }

    /// æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿ã€ã‚¨ãƒ‡ã‚£ã‚¿ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®šã—ã¾ã™ã€‚
    /// ï¼ˆAppå±¤ã«ã‚ˆã£ã¦ã€ã“ã‚ŒãŒå…ƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãŒæ±ºå®šã•ã‚Œã¾ã™ã€‚ï¼‰
    pub fn load_from_file(&mut self, path: &Path) -> io::Result<()> {
        let content = fs::read_to_string(path)?;
        self.buffer = content;
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã ã‚‰ã€ã‚«ãƒ¼ã‚½ãƒ«ã‚’å…ˆé ­ã«è¨­å®šã—ã€é¸æŠã‚’ã‚¯ãƒªã‚¢
        self.set_cursor_position(0, 0, false);
        // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãªã®ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚‚ãƒªã‚»ãƒƒãƒˆ
        self.scroll_offset_y = 0;
        self.scroll_offset_x = 0;
        Ok(())
    }

    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚
    /// ï¼ˆAppå±¤ã«ã‚ˆã£ã¦ã€ã“ã‚ŒãŒå…ƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãŒæ±ºå®šã•ã‚Œã¾ã™ã€‚ï¼‰
    pub fn save_to_file(&self, path: &Path) -> io::Result<()> {
        fs::write(path, &self.buffer)
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’æ–°ã—ã„è«–ç†ä½ç½®ã«ç§»å‹•ã•ã›ã¾ã™ã€‚
    /// ãƒãƒƒãƒ•ã‚¡ã®å¢ƒç•Œã‚’è€ƒæ…®ã—ã¦ä½ç½®ã‚’èª¿æ•´ã—ã€ãã®å¾ŒCursorã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
    /// `extend_selection`ãŒ`true`ã®å ´åˆã€é¸æŠç¯„å›²ã‚’ç¶­æŒã¾ãŸã¯é–‹å§‹ã—ã¾ã™ã€‚
    pub fn set_cursor_position(&mut self, x: u16, y: u16, extend_selection: bool) {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let num_lines = lines.len();

        let mut final_y = y;
        // Yåº§æ¨™ã‚’ãƒãƒƒãƒ•ã‚¡ã®è¡Œæ•°å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—
        if num_lines == 0 {
            final_y = 0;
        } else {
            final_y = final_y.min((num_lines - 1) as u16);
        }

        let mut final_x = x;
        // Xåº§æ¨™ã‚’ç¾åœ¨ã®è¡Œã®æ–‡å­—æ•°å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—
        if num_lines > 0 {
            let current_line_len = lines[final_y as usize].chars().count() as u16;
            // `u16::MAX`ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã¯è¡Œæœ«ã«è¨­å®š
            if x == u16::MAX {
                final_x = current_line_len;
            } else {
                final_x = final_x.min(current_line_len);
            }
        } else {
            final_x = 0;
        }

        // Cursorã®update_positionãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€å®Ÿéš›ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
        self.cursor
            .update_position(final_x, final_y, extend_selection);

        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ›´æ–°å¾Œã€ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´
        // ãŸã ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æç”»é ˜åŸŸã®ã‚µã‚¤ã‚ºã‚’çŸ¥ã‚‰ãªã„ãŸã‚ã€èª¿æ•´ã¯åˆ¥é€” `adjust_viewport_offset` ã§è¡Œã†
    }

    /// æç”»é ˜åŸŸã®ã‚µã‚¤ã‚ºã«åŸºã¥ã„ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´ã—ã€ã‚«ãƒ¼ã‚½ãƒ«ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
    ///
    /// **é‡è¦:** ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯`scroll_offset_y`ã¨`scroll_offset_x`ã‚’è¨­å®šã—ã¾ã™ã€‚
    /// å®Ÿéš›ã®æç”»ã‚’è¡Œã†éš›ã¯ã€`scroll_offset_y`ã‹ã‚‰å§‹ã¾ã‚Šã€`scroll_offset_y + viewport_area.height`ã¾ã§ã®è¡Œã‚’æç”»ã™ã‚‹ã®ã§ã¯ãªãã€
    /// å¿…ãš `self.buffer.lines().count()`ï¼ˆãƒãƒƒãƒ•ã‚¡ã®å®Ÿéš›ã®è¡Œæ•°ï¼‰ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
    /// ä¾‹ãˆã°ã€`for i in self.scroll_offset_y .. min(self.scroll_offset_y + viewport_area.height, self.buffer.lines().count() as u16)`
    /// ã®ã‚ˆã†ã«ãƒ«ãƒ¼ãƒ—ã®çµ‚ç«¯ã‚’åˆ¶é™ã™ã‚‹ã“ã¨ã§ã€å­˜åœ¨ã—ãªã„è¡ŒãŒè¡¨ç¤ºã•ã‚Œã‚‹ã®ã‚’é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚
    pub fn adjust_viewport_offset(&mut self, viewport_area: Rect) {
        let cursor_y = self.cursor.y;
        let cursor_x_logical = self.cursor.x; // è«–ç†çš„ãªæ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
        let viewport_height = viewport_area.height;
        let viewport_width = viewport_area.width;

        const PADDING_Y: u16 = 3; // å‚ç›´æ–¹å‘ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
        const PADDING_X: u16 = 5; // æ°´å¹³æ–¹å‘ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°

        // å‚ç›´ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« (Yè»¸)
        // ã‚«ãƒ¼ã‚½ãƒ«ãŒä¸Šç«¯ã«è¿‘ã¥ã„ãŸå ´åˆ
        if cursor_y < self.scroll_offset_y + PADDING_Y {
            self.scroll_offset_y = cursor_y.saturating_sub(PADDING_Y);
        }
        // ã‚«ãƒ¼ã‚½ãƒ«ãŒä¸‹ç«¯ã«è¿‘ã¥ã„ãŸå ´åˆ
        if cursor_y >= self.scroll_offset_y + viewport_height.saturating_sub(PADDING_Y) {
            self.scroll_offset_y = cursor_y
                .saturating_add(1)
                .saturating_sub(viewport_height)
                .saturating_add(PADDING_Y);
        }

        // æ°´å¹³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« (Xè»¸) - è¡Œã®é•·ã•ã¨Unicodeå¹…ã‚‚è€ƒæ…®
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_line_content = if (cursor_y as usize) < lines.len() {
            lines[cursor_y as usize]
        } else {
            ""
        };

        // ã‚«ãƒ¼ã‚½ãƒ«ã®è«–ç†Xä½ç½® (cursor_x_logical) ã¾ã§ã®éƒ¨åˆ†æ–‡å­—åˆ—ã®è¦–è¦šçš„ãªå¹…ï¼ˆã‚»ãƒ«æ•°ï¼‰ã‚’è¨ˆç®—
        let visual_cursor_x_on_line = RatatuiLine::from(
            current_line_content
                .chars()
                .take(cursor_x_logical as usize)
                .collect::<String>(),
        )
        .width() as u16;

        // ç¾åœ¨ã®è¡Œã®å…¨å¹…ã‚‚è¨ˆç®—ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¯„å›²ã®èª¿æ•´ç”¨ï¼‰
        let current_line_visual_width = RatatuiLine::from(current_line_content).width() as u16;

        if visual_cursor_x_on_line < self.scroll_offset_x + PADDING_X {
            // ã‚«ãƒ¼ã‚½ãƒ«ãŒãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®å·¦ç«¯ã‚ˆã‚Šå·¦ã«ç§»å‹•ã—ãŸå ´åˆ
            self.scroll_offset_x = visual_cursor_x_on_line.saturating_sub(PADDING_X);
        } else if visual_cursor_x_on_line
            >= self.scroll_offset_x + viewport_width.saturating_sub(PADDING_X)
        {
            // ã‚«ãƒ¼ã‚½ãƒ«ãŒãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®å³ç«¯ã‚ˆã‚Šå³ã«ç§»å‹•ã—ãŸå ´åˆ
            // ã‚«ãƒ¼ã‚½ãƒ«è‡ªä½“ã‚’å«ã‚ã‚‹ãŸã‚ã€å°‘ãªãã¨ã‚‚1ã‚»ãƒ«åˆ†å‹•ã‹ã™ã“ã¨ã‚’è€ƒæ…®ï¼ˆæ­£ç¢ºãªå¹…ã¯ParagraphãŒè¨ˆç®—ã™ã‚‹ï¼‰
            self.scroll_offset_x = visual_cursor_x_on_line
                .saturating_add(1)
                .saturating_sub(viewport_width)
                .saturating_add(PADDING_X);
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã€ã¾ãŸãƒãƒƒãƒ•ã‚¡ã®ç¯„å›²ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
        let total_lines = self.buffer.lines().count() as u16;
        if total_lines > viewport_height {
            self.scroll_offset_y = self
                .scroll_offset_y
                .min(total_lines.saturating_sub(viewport_height));
        } else {
            self.scroll_offset_y = 0; // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã‚ˆã‚ŠçŸ­ã„å ´åˆã€å‚ç›´ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ä¸è¦
        }

        if current_line_visual_width > viewport_width {
            self.scroll_offset_x = self
                .scroll_offset_x
                .min(current_line_visual_width.saturating_sub(viewport_width));
        } else {
            self.scroll_offset_x = 0; // ç¾åœ¨ã®è¡ŒãŒãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã‚ˆã‚ŠçŸ­ã„å ´åˆã€æ°´å¹³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ä¸è¦
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯å¸¸ã«0ä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’æ¬¡ã®è¡Œã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn next_line(&mut self, extend_selection: bool) {
        let potential_y = self.cursor.get_potential_next_line_y();
        let current_x = self.cursor.x; // ç¾åœ¨ã®Xåº§æ¨™ã‚’ç¶­æŒã—ã‚ˆã†ã¨ã™ã‚‹
        self.set_cursor_position(current_x, potential_y, extend_selection);
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‰ã®è¡Œã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn previous_line(&mut self, extend_selection: bool) {
        let potential_y = self.cursor.get_potential_previous_line_y();
        let current_x = self.cursor.x; // ç¾åœ¨ã®Xåº§æ¨™ã‚’ç¶­æŒã—ã‚ˆã†ã¨ã™ã‚‹
        self.set_cursor_position(current_x, potential_y, extend_selection);
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’æ¬¡ã®æ–‡å­—ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn next_char(&mut self, extend_selection: bool) {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y;
        let current_x = self.cursor.x;

        if (current_y as usize) < lines.len() {
            let current_line_len = lines[current_y as usize].chars().count() as u16;
            if current_x < current_line_len {
                // ç¾åœ¨ã®è¡Œå†…ã§æ¬¡ã®æ–‡å­—ã¸
                self.set_cursor_position(current_x.saturating_add(1), current_y, extend_selection);
            } else if (current_y as usize + 1) < lines.len() {
                // æ¬¡ã®è¡ŒãŒå­˜åœ¨ã™ã‚‹å ´åˆ
                // è¡Œæœ«ã«ã„ã‚‹å ´åˆã¯æ¬¡ã®è¡Œã®å…ˆé ­ã¸
                self.set_cursor_position(0, current_y.saturating_add(1), extend_selection);
            } else {
                // ãƒãƒƒãƒ•ã‚¡ã®æœ€å¾Œã®è¡Œã®æœ«å°¾ã«ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
                self.set_cursor_position(current_x, current_y, extend_selection); // ç¾åœ¨ã®ä½ç½®ã‚’å†è¨­å®šï¼ˆå®Ÿè³ªä½•ã‚‚ã—ãªã„ï¼‰
            }
        } else {
            // ãƒãƒƒãƒ•ã‚¡ãŒç©ºã¾ãŸã¯æœ€å¾Œã®è¡Œã®æœ«å°¾ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ãŒãã®è¡Œã‚’è¶…ãˆã¦ã„ã‚‹ï¼‰ã«ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
            self.set_cursor_position(current_x, current_y, extend_selection); // ç¾åœ¨ã®ä½ç½®ã‚’å†è¨­å®šï¼ˆå®Ÿè³ªä½•ã‚‚ã—ãªã„ï¼‰
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‰ã®æ–‡å­—ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn previous_char(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        let current_x = self.cursor.x;

        if current_x > 0 {
            // ç¾åœ¨ã®è¡Œå†…ã§å‰ã®æ–‡å­—ã¸
            self.set_cursor_position(current_x.saturating_sub(1), current_y, extend_selection);
        } else if current_y > 0 {
            // è¡Œé ­ã«ã„ã‚‹å ´åˆã¯å‰ã®è¡Œã®æœ«å°¾ã¸
            let previous_line_y = current_y.saturating_sub(1);
            // å‰ã®è¡Œã®å®Ÿéš›ã®é•·ã•ã‚’å–å¾—ã—ã€Xåº§æ¨™ã‚’è¨­å®šï¼ˆ`u16::MAX`ã§Editorã«ã€Œè¡Œæœ«ã€ã‚’ä¼ãˆã‚‹ï¼‰
            self.set_cursor_position(u16::MAX, previous_line_y, extend_selection);
        } else {
            // ãƒãƒƒãƒ•ã‚¡ãŒç©ºã¾ãŸã¯æœ€åˆã®è¡Œã®å…ˆé ­ã«ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
            self.set_cursor_position(current_x, current_y, extend_selection); // ç¾åœ¨ã®ä½ç½®ã‚’å†è¨­å®šï¼ˆå®Ÿè³ªä½•ã‚‚ã—ãªã„ï¼‰
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç¾åœ¨ã®è¡Œã®å…ˆé ­ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn move_cursor_to_line_start(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        self.set_cursor_position(
            self.cursor.get_potential_start_of_line_x(),
            current_y,
            extend_selection,
        );
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç¾åœ¨ã®è¡Œã®æœ«å°¾ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn move_cursor_to_line_end(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        // u16::MAX ã‚’æ¸¡ã—ã¦ã€set_cursor_position ã«è¡Œæœ«ã‚’è¨ˆç®—ã•ã›ã‚‹
        self.set_cursor_position(
            self.cursor.get_potential_end_of_line_x(),
            current_y,
            extend_selection,
        );
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®å…ˆé ­ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn move_cursor_to_document_start(&mut self, extend_selection: bool) {
        let (potential_y, potential_x) = self.cursor.get_potential_document_start_pos();
        self.set_cursor_position(potential_x, potential_y, extend_selection);
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ã‚’ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ«å°¾ã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn move_cursor_to_document_end(&mut self, extend_selection: bool) {
        let (potential_y, potential_x) = self.cursor.get_potential_document_end_pos();
        // u16::MAX ã‚’æ¸¡ã—ã¦ã€set_cursor_position ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ«å°¾ã‚’è¨ˆç®—ã•ã›ã‚‹
        self.set_cursor_position(potential_x, potential_y, extend_selection);
    }

    /// ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰é¸æŠç¯„å›²ã‚’å–å¾—ã—ã¾ã™ã€‚
    /// æˆ»ã‚Šå€¤ã¯ (é–‹å§‹ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ, çµ‚äº†ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ) ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚
    /// é¸æŠç¯„å›²ãŒãªã„å ´åˆã¯Noneã‚’è¿”ã—ã¾ã™ã€‚
    pub fn get_selection_range(&self) -> Option<(usize, usize)> {
        if let Some((start_coords, end_coords)) = self.cursor.get_normalized_selection_coords() {
            // (y, x) åº§æ¨™ã‚’ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            let coords_to_byte_offset = |y_coord: u16, x_coord: u16| -> usize {
                let mut offset = 0;
                for (i, line) in self.buffer.lines().enumerate() {
                    if i == y_coord as usize {
                        // æŒ‡å®šã•ã‚ŒãŸè¡Œã¨åˆ—ã®æ–‡å­—ã‚ªãƒ•ã‚»ãƒƒãƒˆã¾ã§ã®ãƒã‚¤ãƒˆæ•°ã‚’è¨ˆç®—
                        offset += line
                            .chars()
                            .take(x_coord as usize)
                            .map(|c| c.len_utf8())
                            .sum::<usize>();
                        break;
                    }
                    offset += line.len();
                    offset += 1; // æ”¹è¡Œæ–‡å­—ï¼ˆLFï¼‰ã®ãƒã‚¤ãƒˆé•·ã‚’ä»®å®š
                }
                offset
            };

            let start_byte_offset = coords_to_byte_offset(start_coords.0, start_coords.1);
            let end_byte_offset = coords_to_byte_offset(end_coords.0, end_coords.1);

            // é¸æŠç¯„å›²ãŒå®Ÿéš›ã®ãƒ†ã‚­ã‚¹ãƒˆã¨é‡è¤‡ã—ãªã„ã‚ˆã†ã«èª¿æ•´
            if start_byte_offset == end_byte_offset {
                None
            } else {
                Some((start_byte_offset, end_byte_offset))
            }
        } else {
            None
        }
    }

    /// ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹å…¨ä½“ã‚’é¸æŠã—ã¾ã™ã€‚
    pub fn select_all(&mut self) {
        // 1. å…ˆé ­ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•ã—ã€é¸æŠé–‹å§‹
        self.set_cursor_position(0, 0, false); // é¸æŠè§£é™¤ã—ã¦å…ˆé ­ã¸
        // 2. æœ«å°¾ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•ã—ã€é¸æŠã‚’æ‹¡å¼µ
        self.move_cursor_to_document_end(true); // extend_selection = true ã§æœ«å°¾ã¾ã§é¸æŠ
    }

    /// é¸æŠã•ã‚ŒãŸç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
    /// ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚‚æ›¸ãè¾¼ã‚€
    pub fn copy_selection(&mut self) -> Option<String> {
        if let Some((start, end)) = self.get_selection_range() {
            let text = self.buffer[start..end].to_string();
            // OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ›¸ãè¾¼ã‚€ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç„¡è¦–ï¼‰
            if let Ok(mut clipboard) = Clipboard::new() {
                let _ = clipboard.set_text(text.clone());
            }
            Some(text)
        } else {
            None
        }
    }

    /// é¸æŠã•ã‚ŒãŸç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ‡ã‚Šå–ã‚Šã€ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚
    /// ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚‚æ›¸ãè¾¼ã‚€
    pub fn cut_selection(&mut self) -> Option<String> {
        if let Some((start_byte_offset, end_byte_offset)) = self.get_selection_range() {
            let cut_text = self.buffer[start_byte_offset..end_byte_offset].to_string();

            // OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ›¸ãè¾¼ã‚€ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç„¡è¦–ï¼‰
            if let Ok(mut clipboard) = Clipboard::new() {
                let _ = clipboard.set_text(cut_text.clone());
            }

            // åˆ‡ã‚Šå–ã‚Šå¾Œã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ã€é¸æŠç¯„å›²ã®é–‹å§‹ä½ç½®ã«èª¿æ•´ã™ã‚‹
            // ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰æ–°ã—ã„ã‚«ãƒ¼ã‚½ãƒ«åº§æ¨™ã‚’è¨ˆç®—
            let lines_before_cut: Vec<&str> = self.buffer[..start_byte_offset].lines().collect();
            let new_y = (lines_before_cut.len() as u16).saturating_sub(1); // åˆ‡ã‚Šå–ã‚Šé–‹å§‹è¡Œ
            let new_x = if new_y == u16::MAX {
                // ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã§åˆ‡ã‚Šå–ã‚Šã®å ´åˆ
                0
            } else {
                lines_before_cut
                    .last()
                    .map_or(0, |last_line| last_line.chars().count() as u16)
            };

            self.buffer
                .replace_range(start_byte_offset..end_byte_offset, ""); // é¸æŠç¯„å›²ã‚’å‰Šé™¤

            // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’åˆ‡ã‚Šå–ã£ãŸå¾Œã®ä½ç½®ã«è¨­å®šã—ã€é¸æŠã‚’è§£é™¤
            self.set_cursor_position(new_x, new_y, false);
            Some(cut_text)
        } else {
            None
        }
    }

    /// æŒ‡å®šã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ãƒšãƒ¼ã‚¹ãƒˆã—ã¾ã™ã€‚
    pub fn paste_text(&mut self, text: &str) {
        if self.cursor.is_selecting() {
            self.cut_selection(); // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆã¯ã¾ãšåˆ‡ã‚Šå–ã‚‹
        }

        let current_offset = self.get_cursor_byte_offset(); // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
        self.buffer.insert_str(current_offset, text); // ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒ¿å…¥

        let new_cursor_offset = current_offset + text.len(); // æ–°ã—ã„ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
        self.set_cursor_from_byte_offset(new_cursor_offset, false); // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°ã—ã€é¸æŠã‚’è§£é™¤
    }

    /// OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰è²¼ã‚Šä»˜ã‘ã‚‹ã€‚å¤±æ•—ã—ãŸå ´åˆã¯app.clipboardã‚’ä½¿ã†
    pub fn paste_from_clipboard(&mut self, clipboard: &Option<String>) {
        // OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰ãã¡ã‚‰ã‚’å„ªå…ˆ
        if let Ok(mut sys_clip) = Clipboard::new() {
            if let Ok(text) = sys_clip.get_text() {
                self.paste_text(&text);
                return;
            }
        }
        // å¤±æ•—ã—ãŸå ´åˆã¯app.clipboardã‚’ä½¿ã†
        if let Some(text) = clipboard {
            self.paste_text(text);
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«æ–‡å­—ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚
    pub fn insert_char(&mut self, c: char) {
        self.push_undo();
        if self.cursor.is_selecting() {
            self.cut_selection(); // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆã¯ã¾ãšåˆ‡ã‚Šå–ã‚‹
        }

        let current_offset = self.get_cursor_byte_offset(); // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
        self.buffer.insert(current_offset, c); // æ–‡å­—ã‚’æŒ¿å…¥

        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°ï¼ˆæ”¹è¡Œã®å ´åˆã¯æ¬¡ã®è¡Œã®å…ˆé ­ã€ãã‚Œä»¥å¤–ã¯Xåº§æ¨™ã‚’1é€²ã‚ã‚‹ï¼‰
        if c == '\n' {
            self.set_cursor_position(0, self.cursor.y.saturating_add(1), false);
        } else {
            self.set_cursor_position(self.cursor.x.saturating_add(1), self.cursor.y, false);
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ–‡å­—ã€ã¾ãŸã¯é¸æŠç¯„å›²ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ï¼ˆBackspaceç›¸å½“ï¼‰
    pub fn delete_previous_char(&mut self) {
        if self.cursor.is_selecting() {
            self.cut_selection();
            return;
        }

        let current_offset = self.get_cursor_byte_offset(); // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
        if current_offset > 0 {
            // æ–‡å­—ã®å¢ƒç•Œã‚’è€ƒæ…®ã—ã¦ã€å‰ã®æ–‡å­—ã®ãƒã‚¤ãƒˆé–‹å§‹ä½ç½®ã‚’ç‰¹å®š
            let mut char_start_offset = current_offset;
            // ãƒãƒ«ãƒãƒã‚¤ãƒˆæ–‡å­—ã®é€”ä¸­ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹å ´åˆã¯ã€æ–‡å­—ã®å…ˆé ­ã¾ã§æˆ»ã‚‹
            while char_start_offset > 0 && !self.buffer.is_char_boundary(char_start_offset - 1) {
                char_start_offset -= 1;
            }
            if char_start_offset > 0 {
                // å‰ã®æ–‡å­—ï¼ˆchar_start_offset - 1 ã‹ã‚‰å§‹ã¾ã‚‹æ–‡å­—ï¼‰ã‚’å‰Šé™¤
                self.buffer.remove(char_start_offset - 1);
                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ–°ã—ã„ä½ç½®ã«èª¿æ•´ï¼ˆé¸æŠã¯ã‚¯ãƒªã‚¢ï¼‰
                self.set_cursor_from_byte_offset(char_start_offset - 1, false);
            }
        }
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ–‡å­—ã€ã¾ãŸã¯é¸æŠç¯„å›²ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ï¼ˆDeleteã‚­ãƒ¼ç›¸å½“ï¼‰
    pub fn delete_current_char(&mut self) {
        if self.cursor.is_selecting() {
            self.cut_selection();
            return;
        }

        let current_offset = self.get_cursor_byte_offset(); // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
        if current_offset < self.buffer.len() {
            // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰æ¬¡ã®æ–‡å­—ã®ãƒã‚¤ãƒˆçµ‚äº†ä½ç½®ã‚’ç‰¹å®š
            let mut char_start_for_deletion = current_offset;
            // ãƒãƒ«ãƒãƒã‚¤ãƒˆæ–‡å­—ã®é€”ä¸­ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹å ´åˆã¯ã€æ–‡å­—ã®å…ˆé ­ã¾ã§é€²ã‚€
            while char_start_for_deletion < self.buffer.len()
                && !self.buffer.is_char_boundary(char_start_for_deletion)
            {
                char_start_for_deletion += 1;
            }

            // `chars().next()` ã‚’ä½¿ã£ã¦ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ–‡å­—ï¼ˆã¾ãŸã¯æ¬¡ã®æ–‡å­—ï¼‰ã®ãƒã‚¤ãƒˆé•·ã‚’å–å¾—
            let char_len_to_delete = self.buffer[char_start_for_deletion..]
                .chars()
                .next()
                .map_or(0, |c| c.len_utf8());

            if char_len_to_delete > 0 {
                self.buffer.replace_range(
                    char_start_for_deletion..(char_start_for_deletion + char_len_to_delete),
                    "",
                );
                // Deleteã‚­ãƒ¼ã®å ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã¯å¤‰æ›´ã—ãªã„ï¼ˆé¸æŠã¯ã‚¯ãƒªã‚¢ï¼‰
                self.set_cursor_position(self.cursor.x, self.cursor.y, false);
            }
        }
    }

    /// æŒ‡å®šã•ã‚ŒãŸç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ–°ã—ã„ãƒ†ã‚­ã‚¹ãƒˆã§ç½®ãæ›ãˆã¾ã™ã€‚
    pub fn replace_buffer_range(
        &mut self,
        start_byte_offset: usize,
        end_byte_offset: usize,
        new_text: &str,
    ) {
        if start_byte_offset <= end_byte_offset && end_byte_offset <= self.buffer.len() {
            self.buffer
                .replace_range(start_byte_offset..end_byte_offset, new_text);
            let new_cursor_offset = start_byte_offset + new_text.len(); // ç½®æ›å¾Œã®æ–°ã—ã„ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
            self.set_cursor_from_byte_offset(new_cursor_offset, false); // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°ã—ã€é¸æŠã‚’ã‚¯ãƒªã‚¢
        }
    }

    /// ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚
    fn get_cursor_byte_offset(&self) -> usize {
        let mut offset = 0;
        for (current_y, line) in self.buffer.lines().enumerate() {
            if current_y == self.cursor.y as usize {
                // ç¾åœ¨ã®è¡Œã®ã‚«ãƒ¼ã‚½ãƒ«Xä½ç½®ã¾ã§ã®ãƒã‚¤ãƒˆæ•°ã‚’è¨ˆç®—
                offset += line
                    .chars()
                    .take(self.cursor.x as usize)
                    .map(|c| c.len_utf8())
                    .sum::<usize>();
                break;
            }
            offset += line.len(); // è¡Œã®ãƒã‚¤ãƒˆé•·
            offset += 1; // æ”¹è¡Œæ–‡å­— (LF) ã®ãƒã‚¤ãƒˆé•·ã‚’ä»®å®š
        }
        offset
    }

    /// ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰ã‚«ãƒ¼ã‚½ãƒ«ä½ç½® (x, y) ã‚’è¨­å®šã—ã¾ã™ã€‚
    fn set_cursor_from_byte_offset(&mut self, byte_offset: usize, extend_selection: bool) {
        let mut current_offset = 0;
        let mut y = 0;
        let mut x_chars_count = 0;

        for line in self.buffer.lines() {
            let line_len_bytes = line.len();
            // æ”¹è¡Œæ–‡å­—ã‚’å«ã‚€è¡Œã®å…¨é•·ã€‚Rustã®lines()ã¯æ”¹è¡Œã‚’å«ã¾ãªã„ã®ã§ã€ã“ã“ã§+1ã™ã‚‹
            let line_with_newline_len = line_len_bytes + 1; // LFã‚’ä»®å®š

            // ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆãŒç¾åœ¨ã®è¡Œå†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if byte_offset >= current_offset && byte_offset <= current_offset + line_len_bytes {
                let relative_offset = byte_offset - current_offset;

                x_chars_count = 0;
                let mut current_byte_in_line = 0;
                for c in line.chars() {
                    let char_len_bytes = c.len_utf8();
                    if current_byte_in_line + char_len_bytes > relative_offset {
                        // ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒç¾åœ¨ã®æ–‡å­—ã®é€”ä¸­ã«ã‚ã‚Œã°ã€ãã®æ–‡å­—ã®å…ˆé ­ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç½®ã
                        break;
                    }
                    current_byte_in_line += char_len_bytes;
                    x_chars_count += 1;
                }

                // è¡Œã®æ–‡å­—æ•°ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
                x_chars_count = x_chars_count.min(line.chars().count());
                break;
            }

            current_offset += line_with_newline_len;
            y += 1;
        }
        // set_cursor_positionã‚’é€šã˜ã¦ã€Cursorã®update_positionã‚’å‘¼ã³å‡ºã™
        self.set_cursor_position(x_chars_count as u16, y as u16, extend_selection);
    }

    /// ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ‹¬å¼§ã«å¯¾å¿œã™ã‚‹æ‹¬å¼§ã®ä½ç½®ã‚’æ¤œç´¢ã—ã¾ã™ã€‚
    /// æˆ»ã‚Šå€¤ã¯ (y, x) ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚
    pub fn find_matching_paren(&self) -> Option<(u16, u16)> {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y as usize;
        let current_x = self.cursor.x as usize;

        if current_y >= lines.len() {
            return None;
        }

        let current_line_chars: Vec<char> = lines[current_y].chars().collect();
        // ã‚«ãƒ¼ã‚½ãƒ«ãŒç¾åœ¨ã®è¡Œã®æ–‡å­—æ•°ã®å¢ƒç•Œã«ã„ã‚‹å ´åˆã‚‚è€ƒæ…®
        if current_x > current_line_chars.len() {
            return None;
        }

        // ã‚«ãƒ¼ã‚½ãƒ«ãŒæ–‡å­—ã®é–“ã«ã„ã‚‹å ´åˆã¯ã€ãã®å‰ã®æ–‡å­—ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ãŒãã®æ–‡å­—ã®å³å´ã«ã‚ã‚‹ã¨ã¿ãªã™ï¼‰
        let char_at_cursor_or_before = if current_x < current_line_chars.len() {
            current_line_chars[current_x]
        } else if current_x > 0 {
            current_line_chars[current_x - 1] // è¡Œæœ«ã®å ´åˆã¯å‰ã®æ–‡å­—ã‚’è¦‹ã‚‹
        } else {
            return None; // ç©ºã®è¡Œã®å…ˆé ­
        };

        let (open_paren, close_paren, direction) = match char_at_cursor_or_before {
            '(' => ('(', ')', 1), // é †æ–¹å‘æ¤œç´¢
            '{' => ('{', '}', 1),
            '[' => ('[', ']', 1),
            ')' => ('(', ')', -1), // é€†æ–¹å‘æ¤œç´¢
            '}' => ('{', '}', -1),
            ']' => ('[', ']', -1),
            _ => return None, // æ‹¬å¼§ã§ã¯ãªã„
        };

        let mut balance = 0;

        if direction == 1 {
            // é †æ–¹å‘æ¤œç´¢ (ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰çµ‚ç«¯ã¾ã§)
            // ç¾åœ¨ã®è¡Œ
            for (x_idx, ch) in current_line_chars.iter().enumerate().skip(current_x) {
                if *ch == open_paren {
                    balance += 1;
                } else if *ch == close_paren {
                    balance -= 1;
                }
                if balance == 0 {
                    return Some((current_y as u16, x_idx as u16));
                }
            }
            // å¾Œç¶šã®è¡Œ
            for (y_idx, _item) in lines.iter().enumerate().skip(current_y + 1) {
                let line_chars: Vec<char> = lines[y_idx].chars().collect();
                for (x_idx, ch) in line_chars.iter().enumerate() {
                    if *ch == open_paren {
                        balance += 1;
                    } else if *ch == close_paren {
                        balance -= 1;
                    }
                    if balance == 0 {
                        return Some((y_idx as u16, x_idx as u16));
                    }
                }
            }
        } else {
            // é€†æ–¹å‘æ¤œç´¢ (ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰å…ˆé ­ã¾ã§)
            // ç¾åœ¨ã®è¡Œ (ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®1ã¤å‰ã‹ã‚‰é€†é †ã«èµ°æŸ»)
            let start_x_for_backward_search = if current_x > 0 {
                current_x.saturating_sub(1)
            } else {
                0
            };

            for x_idx in (0..=start_x_for_backward_search).rev() {
                let ch = current_line_chars[x_idx];
                if ch == close_paren {
                    balance += 1;
                } else if ch == open_paren {
                    balance -= 1;
                }
                if balance == 0 {
                    return Some((current_y as u16, x_idx as u16));
                }
            }
            // å‰ã®è¡Œ
            for y_idx in (0..current_y).rev() {
                let line_chars: Vec<char> = lines[y_idx].chars().collect();
                for x_idx in (0..line_chars.len()).rev() {
                    let ch = line_chars[x_idx];
                    if ch == close_paren {
                        balance += 1;
                    } else if ch == open_paren {
                        balance -= 1;
                    }
                    if balance == 0 {
                        return Some((y_idx as u16, x_idx as u16));
                    }
                }
            }
        }
        None
    }

    /// ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰ã‚³ãƒ¼ãƒ‰è£œå®Œã®å€™è£œã‚’å–å¾—ã—ã¾ã™ã€‚ï¼ˆéå¸¸ã«ç°¡æ˜“ç‰ˆï¼‰
    /// å®Ÿéš›ã®è£œå®Œã¯ã€è¨€èªã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ« (LSP) ãªã©ã§è¡Œã‚ã‚Œã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
    pub fn get_completion_suggestions(&self) -> Vec<String> {
        let mut suggestions = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y as usize;

        if current_y >= lines.len() {
            return suggestions;
        }

        let current_line_chars: Vec<char> = lines[current_y].chars().collect();
        let current_x = self.cursor.x as usize;

        // ã‚«ãƒ¼ã‚½ãƒ«å‰ã®å˜èªã‚’å–å¾—
        let mut prefix = String::new();
        // ã‚«ãƒ¼ã‚½ãƒ«ã®1ã¤å‰ã‹ã‚‰é€†é †ã«èµ°æŸ»
        for i in (0..current_x).rev() {
            let ch = current_line_chars[i];
            // å˜èªã‚’æ§‹æˆã™ã‚‹æ–‡å­—ï¼ˆè‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ï¼‰ã‚’å®šç¾©
            if ch.is_alphanumeric() || ch == '_' {
                prefix.insert(0, ch); // æ­£ã—ã„é †åºã§å˜èªã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚å…ˆé ­ã«æŒ¿å…¥
            } else {
                break; // å˜èªä»¥å¤–ã®æ–‡å­—ã«é­é‡ã—ãŸã‚‰åœæ­¢
            }
        }

        if prefix.is_empty() {
            return suggestions;
        }

        // ä»®ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ (Rusté¢¨)
        let keywords = vec![
            "fn", "let", "if", "else", "while", "for", "match", "loop", "struct", "enum", "use",
            "mod", "pub", "mut", "return", "break", "continue", "impl", "trait", "where", "async",
            "await", "unsafe",
        ];

        // ä»®ã®è­˜åˆ¥å­ãƒªã‚¹ãƒˆ (ãƒãƒƒãƒ•ã‚¡å†…ã®å˜èªã‹ã‚‰å–å¾—)
        let mut identifiers: std::collections::HashSet<String> = std::collections::HashSet::new();
        for line_str in self.buffer.lines() {
            // è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ä»¥å¤–ã®æ–‡å­—ã§å˜èªã‚’åˆ†å‰²
            for word in line_str.split(|c: char| !(c.is_alphanumeric() || c == '_')) {
                if !word.is_empty() && !keywords.contains(&word) {
                    identifiers.insert(word.to_string());
                }
            }
        }

        // ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã«ãƒãƒƒãƒã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è¿½åŠ 
        for keyword in keywords {
            if keyword.starts_with(&prefix) {
                suggestions.push(keyword.to_string());
            }
        }

        // ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã«ãƒãƒƒãƒã™ã‚‹è­˜åˆ¥å­ã‚’è¿½åŠ 
        for id in identifiers.iter() {
            if id.starts_with(&prefix) {
                suggestions.push(id.clone());
            }
        }

        suggestions.sort_unstable(); // å€™è£œã‚’ã‚½ãƒ¼ãƒˆ
        suggestions.dedup(); // é‡è¤‡ã‚’å‰Šé™¤
        suggestions
    }

    /// æŒ‡å®šã•ã‚ŒãŸã‚¯ã‚¨ãƒªã§ãƒãƒƒãƒ•ã‚¡ã‚’æ¤œç´¢ã—ã€ãƒãƒƒãƒä½ç½®ã‚’ä¿å­˜ã—ã¾ã™ã€‚
    pub fn search(&mut self, query: &str) {
        self.search_query = query.to_string();
        self.search_matches.clear();
        self.current_search_idx = None;

        if query.is_empty() {
            return;
        }

        // å…¨ã¦ã®è¡Œã‚’èµ°æŸ»ã—ã€ã‚¯ã‚¨ãƒªã«ãƒãƒƒãƒã™ã‚‹ä½ç½®ã‚’åé›†
        for (y, line) in self.buffer.lines().enumerate() {
            // `match_indices` ã¯ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿”ã™ãŸã‚ã€æ–‡å­—ã‚ªãƒ•ã‚»ãƒƒãƒˆã«å¤‰æ›ãŒå¿…è¦
            for (byte_x, _) in line.match_indices(query) {
                // ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰æ–‡å­—ã‚ªãƒ•ã‚»ãƒƒãƒˆã«å¤‰æ›
                let char_x = line[..byte_x].chars().count();
                self.search_matches.push((y as u16, char_x as u16));
            }
        }

        if !self.search_matches.is_empty() {
            self.current_search_idx = Some(0);
            let (y, x) = self.search_matches[0];
            self.set_cursor_position(x, y, false); // æœ€åˆã®ãƒãƒƒãƒä½ç½®ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•ï¼ˆé¸æŠã¯ã‚¯ãƒªã‚¢ï¼‰
        }
    }

    /// æ¬¡ã®æ¤œç´¢çµæœã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn next_search_match(&mut self) {
        if self.search_matches.is_empty() {
            return;
        }

        let current_cursor_pos = self.cursor.get_current_pos(); // (x, y)
        let mut next_idx_found = false;
        let mut closest_next_idx = 0; // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®ãƒãƒƒãƒãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæœ€åˆã®ãƒãƒƒãƒï¼‰

        // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚ˆã‚Šã€Œå¾Œã€ã«ã‚ã‚‹ãƒãƒƒãƒã‚’æ¤œç´¢
        for (i, &(match_y, match_x)) in self.search_matches.iter().enumerate() {
            // Cursorã®åº§æ¨™ã¯ (x, y) ãªã®ã§ã€æ¯”è¼ƒã‚’ (y, x) ã«åˆã‚ã›ã¦è¡Œã†
            if (match_y > current_cursor_pos.1) || // æ¬¡ã®è¡Œ
               (match_y == current_cursor_pos.1 && match_x >= current_cursor_pos.0)
            {
                // åŒã˜è¡Œã§ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ä»¥é™
                closest_next_idx = i;
                next_idx_found = true;
                break;
            }
        }

        // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã«è¦‹ã¤ã‹ã£ãŸå ´åˆã¯ãã®ä½ç½®ã¸
        // è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ãƒªã‚¹ãƒˆã®å…ˆé ­ã«æˆ»ã‚‹ (ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰)
        let final_idx = if next_idx_found { closest_next_idx } else { 0 };

        self.current_search_idx = Some(final_idx);
        let (y, x) = self.search_matches[final_idx];
        self.set_cursor_position(x, y, false); // æ¤œç´¢çµæœã«ç§»å‹•ï¼ˆé¸æŠã¯ã‚¯ãƒªã‚¢ï¼‰
    }

    /// å‰ã®æ¤œç´¢çµæœã«ç§»å‹•ã—ã¾ã™ã€‚
    pub fn previous_search_match(&mut self) {
        if self.search_matches.is_empty() {
            return;
        }

        let current_cursor_pos = self.cursor.get_current_pos(); // (x, y)
        let mut prev_idx_found = false;
        let mut closest_prev_idx = self.search_matches.len().saturating_sub(1); // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå‰ã®ãƒãƒƒãƒãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæœ€å¾Œã®ãƒãƒƒãƒï¼‰

        // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚ˆã‚Šã€Œå‰ã€ã«ã‚ã‚‹ãƒãƒƒãƒã‚’æ¤œç´¢ (ãƒªã‚¹ãƒˆã‚’é€†é †ã«èµ°æŸ»)
        for (i, &(match_y, match_x)) in self.search_matches.iter().rev().enumerate() {
            let original_idx = self.search_matches.len() - 1 - i; // å…ƒã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›
            // Cursorã®åº§æ¨™ã¯ (x, y) ãªã®ã§ã€æ¯”è¼ƒã‚’ (y, x) ã«åˆã‚ã›ã¦è¡Œã†
            if (match_y < current_cursor_pos.1) || // å‰ã®è¡Œ
               (match_y == current_cursor_pos.1 && match_x <= current_cursor_pos.0)
            {
                // åŒã˜è¡Œã§ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ä»¥å‰
                closest_prev_idx = original_idx;
                prev_idx_found = true;
                break;
            }
        }

        // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå‰ã«è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ãƒªã‚¹ãƒˆã®æœ«å°¾ã«æˆ»ã‚‹ (ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰)
        let final_idx = if prev_idx_found {
            closest_prev_idx
        } else {
            self.search_matches.len().saturating_sub(1)
        };

        self.current_search_idx = Some(final_idx);
        let (y, x) = self.search_matches[final_idx];
        self.set_cursor_position(x, y, false); // æ¤œç´¢çµæœã«ç§»å‹•ï¼ˆé¸æŠã¯ã‚¯ãƒªã‚¢ï¼‰
    }

    pub fn copy_selection_to_clipboard(&mut self) -> Option<String> {
        if let Some((start, end)) = self.get_selection_range() {
            let text = self.buffer[start..end].to_string();
            let mut clipboard = Clipboard::new().ok();
            if let Some(ref mut cb) = clipboard {
                let _ = cb.set_text(text.clone());
            }
            Some(text)
        } else {
            None
        }
    }

    /// app.clipboardã‹ã‚‰è²¼ã‚Šä»˜ã‘ã‚‹ï¼ˆOSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¯å‚ç…§ã—ãªã„ï¼‰
    // pub fn paste_from_clipboard(&mut self, clipboard: &Option<String>) {
    //     // OSã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰ãã¡ã‚‰ã‚’å„ªå…ˆ
    //     if let Ok(mut sys_clip) = Clipboard::new() {
    //         if let Ok(text) = sys_clip.get_text() {
    //             self.paste_text(&text);
    //             return;
    //         }
    //     }
    //     // å¤±æ•—ã—ãŸå ´åˆã¯app.clipboardã‚’ä½¿ã†
    //     if let Some(text) = clipboard {
    //         self.paste_text(text);
    //     }
    // }

    /// ç·¨é›†æ“ä½œã®å‰ã«å‘¼ã³å‡ºã—ã¦å±¥æ­´ã‚’ç©ã‚€
    fn push_undo(&mut self) {
        self.undo_stack.push(self.buffer.clone());
        self.redo_stack.clear();
    }

    pub fn undo(&mut self) {
        if let Some(prev) = self.undo_stack.pop() {
            self.redo_stack.push(self.buffer.clone());
            self.buffer = prev;
            // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚‚å¾©å…ƒã—ãŸã„å ´åˆã¯åˆ¥é€”ä¿å­˜ãŒå¿…è¦
        }
    }

    pub fn redo(&mut self) {
        if let Some(next) = self.redo_stack.pop() {
            self.undo_stack.push(self.buffer.clone());
            self.buffer = next;
        }
    }

    /// æŠ˜è¿”ã—ãƒ¢ãƒ¼ãƒ‰ç”¨: ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã•ã«åˆã‚ã›ãŸç”»é¢ä¸Šã®è¡Œãƒªã‚¹ãƒˆã‚’è¿”ã™
    /// æˆ»ã‚Šå€¤ã¯ (ãƒãƒƒãƒ•ã‚¡è¡Œç•ªå·, æŠ˜è¿”ã—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹, ç”»é¢è¡Œæ–‡å­—åˆ—)
    pub fn get_visual_lines(&self) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        // ä»®: 1ç”»é¢è¡Œ=40æ–‡å­—ã§æŠ˜è¿”ã—ï¼ˆæœ¬æ¥ã¯ã‚¨ãƒ‡ã‚£ã‚¿å¹…ã‚’å¼•æ•°ã§å—ã‘ã‚‹ã¹ãï¼‰
        let wrap_width = 40;
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            let mut start = 0;
            let mut wrap_idx = 0;
            let chars: Vec<char> = line.chars().collect();
            while start < chars.len() {
                let end = (start + wrap_width).min(chars.len());
                let visual = chars[start..end].iter().collect::<String>();
                result.push((buf_idx, wrap_idx, visual));
                start = end;
                wrap_idx += 1;
            }
        }
        result
    }
    /// æŠ˜è¿”ã—ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ: wrapè¡Œå˜ä½ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’ä¸Šä¸‹ç§»å‹•
    pub fn next_visual_line(&mut self, area_width: usize, extend_selection: bool) {
        let visual_lines = self.get_visual_lines_with_width(area_width);
        let mut found = None;
        for (i, (buf_idx, wrap_idx, _)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                found = Some(i);
                break;
            }
        }
        if let Some(i) = found {
            if i + 1 < visual_lines.len() {
                let (next_buf_idx, next_wrap_idx, next_line) = &visual_lines[i + 1];
                let x = self.cursor.x.min(next_line.chars().count() as u16);
                self.cursor.x = x;
                self.cursor.y = *next_buf_idx as u16;
                self.cursor_wrap_idx = *next_wrap_idx;
                self.cursor.update_position(x, *next_buf_idx as u16, extend_selection);
            }
        }
    }
    pub fn previous_visual_line(&mut self, area_width: usize, extend_selection: bool) {
        let visual_lines = self.get_visual_lines_with_width(area_width);
        let mut found = None;
        for (i, (buf_idx, wrap_idx, _)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                found = Some(i);
                break;
            }
        }
        if let Some(i) = found {
            if i > 0 {
                let (prev_buf_idx, prev_wrap_idx, prev_line) = &visual_lines[i - 1];
                let x = self.cursor.x.min(prev_line.chars().count() as u16);
                self.cursor.x = x;
                self.cursor.y = *prev_buf_idx as u16;
                self.cursor_wrap_idx = *prev_wrap_idx;
                self.cursor.update_position(x, *prev_buf_idx as u16, extend_selection);
            }
        }
    }
    /// æŒ‡å®šå¹…ã§wrapã—ãŸvisual linesã‚’è¿”ã™ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä¿æŒï¼‰
    pub fn get_visual_lines_with_width(&self, wrap_width: usize) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆéƒ¨åˆ†ã‚’æŠ½å‡º
            let indent: String = line.chars().take_while(|c| c.is_whitespace()).collect();
            let mut start = 0;
            let mut wrap_idx = 0;
            let chars: Vec<char> = line.chars().collect();
            while start < chars.len() {
                let is_first = wrap_idx == 0;
                let available_width = if is_first || wrap_width == usize::MAX {
                    wrap_width
                } else {
                    wrap_width.saturating_sub(indent.chars().count())
                };
                let end = if available_width == 0 || available_width == usize::MAX {
                    chars.len()
                } else {
                    (start + available_width).min(chars.len())
                };
                let mut visual = chars[start..end].iter().collect::<String>();
                if !is_first && !indent.is_empty() {
                    visual = format!("{}{}", indent, visual);
                }
                result.push((buf_idx, wrap_idx, visual));
                if end == chars.len() { break; }
                start = end;
                wrap_idx += 1;
            }
        }
        result
    }
    /// æŒ‡å®šå¹…ã§wrapã—ãŸvisual linesã‚’è¿”ã™ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä¿æŒã€å˜èªå˜ä½wrapï¼‰
    pub fn get_visual_lines_with_width_word_wrap(&self, wrap_width: usize) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆéƒ¨åˆ†ã‚’æŠ½å‡º
            let indent: String = line.chars().take_while(|c| c.is_whitespace()).collect();
            let mut wrap_idx = 0;
            let mut current = 0;
            let chars: Vec<char> = line.chars().collect();
            let mut first = true;
            while current < chars.len() {
                let available_width = if first || wrap_width == usize::MAX {
                    wrap_width
                } else {
                    wrap_width.saturating_sub(indent.chars().count())
                };
                if available_width == 0 || available_width == usize::MAX {
                    let visual = chars[current..].iter().collect::<String>();
                    result.push((buf_idx, wrap_idx, if first { visual.clone() } else { format!("{}{}", indent, visual) }));
                    break;
                }
                // å˜èªå˜ä½ã§wrap
                let mut end = current + available_width;
                if end >= chars.len() {
                    end = chars.len();
                } else {
                    // é€”ä¸­ã§å˜èªãŒåˆ‡ã‚Œã‚‹å ´åˆã€ç›´å‰ã®ç©ºç™½ã¾ã§æˆ»ã™
                    let mut back = end;
                    while back > current && !chars[back-1].is_whitespace() {
                        back -= 1;
                    }
                    if back > current {
                        end = back;
                      }
                }
                if end == current {
                    // 1å˜èªãŒwrapå¹…ã‚’è¶…ãˆã‚‹å ´åˆã¯å¼·åˆ¶åˆ†å‰²
                    end = (current + wrap_width).min(chars.len());
                }
                let mut visual = chars[current..end].iter().collect::<String>();
                if !first && !indent.is_empty() {
                    visual = format!("{}{}", indent, visual);
                }
                result.push((buf_idx, wrap_idx, visual));
                if end == chars.len() { break; }
                current = end;
                wrap_idx += 1;
                first = false;
            }
        }
        result
    }

    /// æŒ‡å®šã—ãŸvisual lineã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿”ã™ï¼ˆword wrapå¯¾å¿œï¼‰
    pub fn get_visual_line_global_offset(&self, buf_idx: usize, wrap_idx: usize, wrap_width: usize) -> usize {
        let lines: Vec<&str> = self.buffer.lines().collect();
        if buf_idx >= lines.len() { return 0; }
        let mut offset = 0;
        // buf_idxã¾ã§ã®å…¨è¡Œã®ãƒã‚¤ãƒˆæ•°+æ”¹è¡Œ
        for i in 0..buf_idx {
            offset += lines[i].len();
            offset += 1; // æ”¹è¡Œ
        }
        // wrap_idxåˆ†ã ã‘ã“ã®è¡Œã®å…ˆé ­ã‹ã‚‰ãƒã‚¤ãƒˆæ•°ã‚’åŠ ç®—
        let line = lines[buf_idx];
        let chars: Vec<char> = line.chars().collect();
        let mut current = 0;
        let mut widx = 0;
        let indent_len = line.chars().take_while(|c| c.is_whitespace()).count();
        while widx < wrap_idx && current < chars.len() {
            let available_width = if widx == 0 || wrap_width == usize::MAX {
                wrap_width
            } else {
                wrap_width.saturating_sub(indent_len)
            };
            let mut end = current + available_width;
            if end >= chars.len() {
                end = chars.len();
            } else {
                let mut back = end;
                while back > current && !chars[back-1].is_whitespace() {
                    back -= 1;
                }
                if back > current {
                    end = back;
                }
            }
            if end == current {
                end = (current + available_width).min(chars.len());
            }
            for c in &chars[current..end] {
                offset += c.len_utf8();
            }
            current = end;
            widx += 1;
        }
        offset
    }

    /// ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ãŒvisual_linesã®ä½•ç•ªç›®ã‹ã€ãã®ä¸­ã§ä½•æ–‡å­—ç›®ã‹ã‚’è¿”ã™ï¼ˆword wrapå¯¾å¿œï¼‰
    pub fn get_cursor_visual_position(&self, wrap_width: usize) -> (usize, usize) {
        let visual_lines = self.get_visual_lines_with_width_word_wrap(wrap_width);
        for (i, (buf_idx, wrap_idx, line_str)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                // ã‚«ãƒ¼ã‚½ãƒ«ã®xã¯wrap_idxåŒºé–“å†…ã§ã®ç›¸å¯¾ä½ç½®
                let indent_len = line_str.chars().take_while(|c| c.is_whitespace()).count();
                let start = if *wrap_idx == 0 { 0 } else { indent_len };
                let rel_x = self.cursor.x.saturating_sub(start as u16) as usize;
                return (i, rel_x.min(line_str.chars().count()));
            }
        }
        (0, 0)
    }
}
===========
===========src/app/msg.rs
// src/components/msg.rs

/// UIå†…ã«è¡¨ç¤ºã•ã‚Œã‚‹æƒ…å ±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’Appã®ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã™ã‚‹ãŸã‚ã®ãƒã‚¯ãƒ­ã€‚
///
/// ä½¿ç”¨ä¾‹: `msg!(app, "Hello, world!");`
/// ä½¿ç”¨ä¾‹: `msg!(app, "Value: {}", some_value);`
///
/// æœ€åˆã®å¼•æ•°ã¨ã—ã¦ `&mut App` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
#[macro_export]
macro_rules! msg {
    ($app:expr, $($arg:tt)*) => {{
        // `format!`ã‚’ä½¿ã£ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
        let message = format!($($arg)*);
        // Appã®add_messageãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
        $app.add_message($crate::app::MessageType::Info, message);
    }};
}

/// UIå†…ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’Appã®ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã™ã‚‹ãŸã‚ã®ãƒã‚¯ãƒ­ã€‚
///
/// ä½¿ç”¨ä¾‹: `emsg!(app, "Error: File not found!");`
/// ä½¿ç”¨ä¾‹: `emsg!(app, "Failed with code: {}", error_code);`
///
/// æœ€åˆã®å¼•æ•°ã¨ã—ã¦ `&mut App` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
#[macro_export]
macro_rules! emsg {
    ($app:expr, $($arg:tt)*) => {{
        // `format!`ã‚’ä½¿ã£ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
        let message = format!($($arg)*);
        // Appã®add_messageãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
        $app.add_message($crate::app::MessageType::Error, message);
    }};
}

// ãƒã‚¯ãƒ­ãŒå¤–éƒ¨ã§åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã¯ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å…¬é–‹ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
// ä¾‹: main.rs ã®å…ˆé ­ã§ `#[macro_use] extern crate <your_crate_name>;` ã‚’è¨˜è¿°ã™ã‚‹ã‹ã€
// crate::components::msg ã‚’ pub use ã™ã‚‹ã€‚
// RataTuiã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã§ã¯ã€é€šå¸¸ã€`main.rs`ã§`use crate::msg;`ã®ã‚ˆã†ã«ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
===========
===========src/app/features/syntax.rs
//! ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½ã¨ã€è¨€èªã®è‡ªå‹•åˆ¤åˆ¥ãƒ­ã‚¸ãƒƒã‚¯ã‚’æä¾›ã—ã¾ã™ã€‚
use ratatui::style::{Color, Modifier, Style};
use std::{collections::HashMap, path::Path};
use syntect::{
    easy::HighlightLines,
    highlighting::{Color as SyntectColor, FontStyle, Style as SyntectStyle, Theme, ThemeSet},
    parsing::{SyntaxReference, SyntaxSet},
};
pub mod themes;
/// ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¾ã™ã€‚
pub struct Highlighter {
    pub syntax_set: SyntaxSet,
    pub theme_set: ThemeSet,
    themes: HashMap<String, Theme>,
    pub current_theme_name: String,
}

impl Default for Highlighter {
    fn default() -> Self {
        let syntax_set = SyntaxSet::load_defaults_newlines();
        let theme_set = ThemeSet::load_defaults();
        let current_theme_name = "Solarized (dark)".to_string(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ¼ãƒ

        let mut themes = HashMap::new();
        // ThemeSetã‹ã‚‰å…¨ã¦ã®ãƒ†ãƒ¼ãƒã‚’HashMapã«ã‚³ãƒ”ãƒ¼ã—ã¦ä¿æŒ
        for (name, theme) in theme_set.themes.iter() {
            themes.insert(name.clone(), theme.clone());
        }
        for (name, theme) in themes::themes() {
            themes.insert(name, theme);
        }
        Highlighter {
            syntax_set,
            theme_set,
            themes,
            current_theme_name,
        }
    }
}

impl Highlighter {
    /// æ–°ã—ã„Highlighterã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
    pub fn new() -> Self {
        Self::default()
    }

    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰æœ€é©ãªã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æ¨æ¸¬ã—ã¾ã™ã€‚
    pub fn get_syntax_for_file(&self, path: Option<&Path>, first_lines: &str) -> &SyntaxReference {
        if let Some(path) = path {
            if let Some(extension) = path.extension().and_then(|s| s.to_str()) {
                if let Some(syntax) = self.syntax_set.find_syntax_by_extension(extension) {
                    return syntax;
                }
            }
        }
        // Shebang (ä¾‹: #!/bin/bash) ã‹ã‚‰è¨€èªã‚’æ¨æ¸¬
        if let Some(syntax) = self.syntax_set.find_syntax_by_first_line(first_lines) {
            return syntax;
        }
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™
        self.syntax_set.find_syntax_plain_text()
    }

    /// ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã‚’å–å¾—ã—ã¾ã™ã€‚
    pub fn get_current_theme(&self) -> &Theme {
        self.themes
            .get(&self.current_theme_name)
            .unwrap_or_else(|| &self.theme_set.themes["Solarized (dark)"]) // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    }

    /// æŒ‡å®šã•ã‚ŒãŸè¡Œã«å¯¾ã—ã¦ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’é©ç”¨ã—ã€`syntect`ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒ†ã‚­ã‚¹ãƒˆã®ãƒšã‚¢ã®Vecã‚’è¿”ã—ã¾ã™ã€‚
    pub fn highlight_line<'a>(
        &self,
        line: &'a str,
        syntax: &SyntaxReference,
    ) -> Vec<(SyntectStyle, &'a str)> {
        let mut highlighter = HighlightLines::new(syntax, self.get_current_theme());
        highlighter
            .highlight_line(line, &self.syntax_set)
            .unwrap_or_else(|_| vec![(SyntectStyle::default(), line)])
    }

    /// `syntect`ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’`ratatui`ã®ã‚¹ã‚¿ã‚¤ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚
    pub fn convert_syntect_style_to_ratatui_style(s: SyntectStyle) -> Style {
        let mut style = Style::default();

        style = style.fg(convert_syntect_color(s.foreground));
        style = style.bg(convert_syntect_color(s.background));

        if s.font_style.contains(FontStyle::BOLD) {
            style = style.add_modifier(Modifier::BOLD);
        }
        if s.font_style.contains(FontStyle::ITALIC) {
            style = style.add_modifier(Modifier::ITALIC);
        }
        if s.font_style.contains(FontStyle::UNDERLINE) {
            style = style.add_modifier(Modifier::UNDERLINED);
        }
        style
    }

    /// ãƒ†ãƒ¼ãƒã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚æˆåŠŸã—ãŸå ´åˆã¯trueã‚’è¿”ã—ã¾ã™ã€‚
    pub fn set_theme(&mut self, theme_name: &str) -> bool {
        if self.themes.contains_key(theme_name) {
            self.current_theme_name = theme_name.to_string();
            true
        } else {
            // ThemeSetã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã‚’è©¦ã¿ã‚‹
            if let Some(theme) = self.theme_set.themes.get(theme_name) {
                self.themes.insert(theme_name.to_string(), theme.clone());
                self.current_theme_name = theme_name.to_string();
                true
            } else {
                false
            }
        }
    }

    /// åˆ©ç”¨å¯èƒ½ãªãƒ†ãƒ¼ãƒåã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚
    pub fn list_themes(&self) -> Vec<String> {
        let mut themes: Vec<String> = self.theme_set.themes.keys().cloned().collect();
        themes.sort_unstable();
        themes
    }

    /// ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã®èƒŒæ™¯è‰²ã‚’`ratatui::style::Color`ã§å–å¾—ã—ã¾ã™ã€‚
    pub fn get_background_color(&self) -> Color {
        let theme = self.get_current_theme();
        theme
            .settings
            .background
            .map_or(Color::Black, convert_syntect_color)
    }

    /// ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã®å‰æ™¯è‰²ï¼ˆåŸºæœ¬ãƒ†ã‚­ã‚¹ãƒˆè‰²ï¼‰ã‚’`ratatui::style::Color`ã§å–å¾—ã—ã¾ã™ã€‚
    pub fn get_foreground_color(&self) -> Color {
        let theme = self.get_current_theme();
        theme
            .settings
            .foreground
            .map_or(Color::White, convert_syntect_color)
    }
}

/// `syntect`ã®`Color`ã‚’`ratatui`ã®`Color`ã«å¤‰æ›ã—ã¾ã™ã€‚
fn convert_syntect_color(c: SyntectColor) -> Color {
    Color::Rgb(c.r, c.g, c.b)
}
===========
===========src/app/features/syntax/themes.rs
use syntect::highlighting::{Color as SyntectColor, Theme, ThemeSettings};

fn midnight_theme() -> (String, Theme) {
    (
        "Midnight".to_string(),
        Theme {
            name: Some("Midnight".to_string()),
            settings: ThemeSettings {
                background: Some(SyntectColor {
                    r: 20,
                    g: 24,
                    b: 31,
                    a: 0xFF,
                }),
                foreground: Some(SyntectColor {
                    r: 220,
                    g: 220,
                    b: 220,
                    a: 0xFF,
                }),
                caret: Some(SyntectColor {
                    r: 80,
                    g: 160,
                    b: 255,
                    a: 0xFF,
                }),
                selection: Some(SyntectColor {
                    r: 60,
                    g: 80,
                    b: 120,
                    a: 0xFF,
                }),
                ..ThemeSettings::default()
            },
            ..Theme::default()
        },
    )
}

fn gruvbox_dark_theme() -> (String, Theme) {
    (
        "Gruvbox Dark".to_string(),
        Theme {
            name: Some("Gruvbox Dark".to_string()),
            settings: ThemeSettings {
                background: Some(SyntectColor {
                    r: 40,
                    g: 40,
                    b: 40,
                    a: 0xFF,
                }),
                foreground: Some(SyntectColor {
                    r: 235,
                    g: 219,
                    b: 178,
                    a: 0xFF,
                }),
                caret: Some(SyntectColor {
                    r: 250,
                    g: 189,
                    b: 47,
                    a: 0xFF,
                }),
                selection: Some(SyntectColor {
                    r: 60,
                    g: 56,
                    b: 54,
                    a: 0xFF,
                }),
                ..ThemeSettings::default()
            },
            ..Theme::default()
        },
    )
}
pub fn themes() -> Vec<(String, Theme)> {
    vec![gruvbox_dark_theme(), midnight_theme()]
}
===========
===========src/app/features.rs
pub mod syntax;
===========
===========src/app/editor/suggest.rs
use std::collections::HashSet;

/// ã‚«ãƒ¼ã‚½ãƒ«ç›´å‰ã®å˜èªã‚’å–å¾—ã—ã¾ã™ã€‚
pub fn get_prefix(buffer: &str, cursor_y: u16, cursor_x: u16) -> String {
    let lines: Vec<&str> = buffer.lines().collect();
    if (cursor_y as usize) >= lines.len() {
        return String::new();
    }
    let line = lines[cursor_y as usize];
    let chars: Vec<char> = line.chars().collect();
    let mut prefix = String::new();
    for i in (0..cursor_x as usize).rev() {
        let ch = chars.get(i).copied().unwrap_or('\0');
        if ch.is_alphanumeric() || ch == '_' {
            prefix.insert(0, ch);
        } else {
            break;
        }
    }
    prefix
}

/// è£œå®Œå€™è£œã‚’è¿”ã—ã¾ã™ï¼ˆRusté¢¨ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‹ãƒãƒƒãƒ•ã‚¡å†…ã®è­˜åˆ¥å­ï¼‰ã€‚
pub fn get_suggestions(buffer: &str, prefix: &str) -> Vec<String> {
    let keywords = [
        "fn", "let", "if", "else", "while", "for", "match", "loop", "struct", "enum", "use", "mod",
        "pub", "mut", "return", "break", "continue", "impl", "trait", "where", "async", "await",
        "unsafe",
    ];
    let mut suggestions: Vec<String> = keywords
        .iter()
        .filter(|kw| kw.starts_with(prefix))
        .map(|s| s.to_string())
        .collect();

    let mut identifiers = HashSet::new();
    for line in buffer.lines() {
        for word in line.split(|c: char| !(c.is_alphanumeric() || c == '_')) {
            if !word.is_empty() && word.starts_with(prefix) && !keywords.contains(&word) {
                identifiers.insert(word.to_string());
            }
        }
    }
    suggestions.extend(identifiers);
    suggestions.sort();
    suggestions.dedup();
    suggestions
}
===========
===========src/app/editor/search.rs
/// ãƒ†ã‚­ã‚¹ãƒˆãƒãƒƒãƒ•ã‚¡å†…ã§ã‚¯ã‚¨ãƒªã«ä¸€è‡´ã™ã‚‹ä½ç½®ã‚’ã™ã¹ã¦è¿”ã—ã¾ã™ã€‚
/// æˆ»ã‚Šå€¤ã¯ (è¡Œç•ªå·, æ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹) ã®ãƒ™ã‚¯ã‚¿ã§ã™ã€‚
pub fn search_all(buffer: &str, query: &str) -> Vec<(u16, u16)> {
    let mut matches = Vec::new();
    if query.is_empty() {
        return matches;
    }
    for (y, line) in buffer.lines().enumerate() {
        for (byte_x, _) in line.match_indices(query) {
            let char_x = line[..byte_x].chars().count() as u16;
            matches.push((y as u16, char_x));
        }
    }
    matches
}

/// æœ€åˆã«ä¸€è‡´ã—ãŸä½ç½®ã‚’è¿”ã—ã¾ã™ã€‚ãªã‘ã‚Œã°Noneã€‚
pub fn search_first(buffer: &str, query: &str) -> Option<(u16, u16)> {
    search_all(buffer, query).into_iter().next()
}===========
===========src/ui.rs
// src/ui.rs
use crate::{
    app::App,
    components::{
        bottom_bar::render_bottom_bar,
        message_display::render_message_display,
        middle_block::editor_block::render_editor_block,
        middle_block::left_block::render_left_block,
        middle_block::right_block::render_right_block,
        popup::{PopupKind, render_popup}, // â† ä¿®æ­£
        top_bar::render_top_bar,
    },
};
use ratatui::{
    Frame,
    layout::{Constraint, Direction, Layout, Rect},
};

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®UIã‚’æç”»ã—ã¾ã™ã€‚
pub fn draw_ui(f: &mut Frame, app: &mut App) {
    let size = f.area();

    // ãƒ¡ã‚¤ãƒ³ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒãƒ£ãƒ³ã‚¯ã‚’å®šç¾©
    let main_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(1), // Top Bar (ã‚¿ã‚¤ãƒˆãƒ«)
                Constraint::Min(0),    // ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿é ˜åŸŸï¼ˆLeft + Editor + Rightï¼‰
                Constraint::Length(1), // Bottom Bar (ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®)
            ]
            .as_ref(),
        )
        .split(size);

    // Top Bar ã®æç”»
    render_top_bar(f, main_chunks[0], app);

    // ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿é ˜åŸŸã‚’ã•ã‚‰ã«åˆ†å‰² (Left Block + Editor Block + Right Block)
    let editor_area_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints(
            [
                Constraint::Length(7), // Left Block (è¡Œç•ªå·ã¨å·®åˆ†ã‚·ãƒ³ãƒœãƒ«ã€ä¾‹: " 999 + ")
                Constraint::Min(0),    // Editor Block (ã‚¨ãƒ‡ã‚£ã‚¿æœ¬ä½“)
                Constraint::Length(3), // Right Block (ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã¨å·®åˆ†ãƒãƒ¼ã‚«ãƒ¼)
            ]
            .as_ref(),
        )
        .split(main_chunks[1]); // main_chunks[1] ãŒã‚¨ãƒ‡ã‚£ã‚¿ã®è¦ªé ˜åŸŸ

    // Middle Block ã®æç”»å‰ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´
    // ã“ã“ã§ `editor_area_chunks[1]` (Editor Block ã®é ˜åŸŸ) ã‚’æ¸¡ã™ã®ãŒé©åˆ‡ã§ã™ã€‚
    app.editor.adjust_viewport_offset(editor_area_chunks[1]);

    // Left Block ã®æç”»
    render_left_block(f, editor_area_chunks[0], app);

    // Editor Block ã®æç”»
    render_editor_block(f, editor_area_chunks[1], app);

    // Right Block ã®æç”»
    render_right_block(f, editor_area_chunks[2], app);

    // Bottom Bar ã®æç”»
    render_bottom_bar(f, main_chunks[2], app);

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ã‚¨ãƒªã‚¢ã‚’è¨ˆç®— (ç”»é¢å…¨ä½“ã®å³ä¸‹)
    const MAX_MESSAGE_HEIGHT: u16 = 5;
    const MESSAGE_WIDTH: u16 = 40;
    const MESSAGE_MARGIN: u16 = 1;

    let actual_message_lines = app.get_visible_message_count().min(MAX_MESSAGE_HEIGHT);

    let msg_area = if actual_message_lines > 0 {
        Rect {
            x: size
                .width
                .saturating_sub(MESSAGE_WIDTH)
                .saturating_sub(MESSAGE_MARGIN),
            y: size
                .height
                .saturating_sub(actual_message_lines)
                .saturating_sub(MESSAGE_MARGIN),
            width: MESSAGE_WIDTH,
            height: actual_message_lines,
        }
    } else {
        Rect::new(0, 0, 0, 0)
    };

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ã®æç”»
    render_message_display(f, msg_area, app);

    // çµ‚äº†ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯æç”»
    if let Some(exit_popup_state) = &app.exit_popup_state {
        if exit_popup_state.input_mode {
            render_popup(
                f,
                size,
                PopupKind::Input {
                    message: "ä¿å­˜å…ˆãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
                    input: &exit_popup_state.input_text,
                },
                exit_popup_state,
            );
        } else {
            render_popup(f, size, PopupKind::Exit, exit_popup_state);
        }
    }
}
===========
===========src/event_handler.rs
// src/event_handler.rs

use crate::app::{App, AppControlFlow, ExitPopupResult};
use crate::{emsg, msg}; // â† ä¿®æ­£: appãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµŒç”±ã§emsg, msgã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
use crossterm::event::{KeyCode, KeyEvent, KeyEventKind, KeyModifiers};

/// ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
/// æˆ»ã‚Šå€¤ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¬¡ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚’ç¤ºã—ã¾ã™ã€‚
pub fn handle_event(app: &mut App, key: &KeyEvent) -> std::io::Result<AppControlFlow> {
    // ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ã‚’å‡¦ç†ï¼ˆç¹°ã‚Šè¿”ã—ã‚„ãƒªãƒªãƒ¼ã‚¹ã¯ç„¡è¦–ï¼‰
    if key.kind == KeyEventKind::Press {
        let extend_selection = key.modifiers.contains(KeyModifiers::SHIFT);

        // --- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤ºä¸­ã®å‡¦ç† ---
        if let Some(popup_state) = app.exit_popup_state.as_mut() {
            // å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰æ™‚
            if popup_state.input_mode {
                match key.code {
                    KeyCode::Enter => {
                        if !popup_state.input_text.is_empty() {
                            app.target_path =
                                Some(std::path::PathBuf::from(&popup_state.input_text));
                            popup_state.input_mode = false;
                            popup_state.input_text.clear();
                            // SaveAndExitãªã‚‰exitã€ãã†ã§ãªã‘ã‚Œã°Continue
                            let is_save_and_exit = matches!(
                                popup_state.selected_option,
                                crate::app::ExitPopupOption::SaveAndExit
                            );
                            app.exit_popup_state = None;
                            match app.save_current_file() {
                                Ok(_) => msg!(app, "ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚"),
                                Err(e) => emsg!(app, "ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e),
                            }
                            if is_save_and_exit {
                                return Ok(AppControlFlow::TriggerSaveAndExit);
                            } else {
                                return Ok(AppControlFlow::Continue);
                            }
                        } else {
                            popup_state.input_mode = false;
                            msg!(app, "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒç©ºã§ã™ã€‚");
                            return Ok(AppControlFlow::ShowExitPopup);
                        }
                    }
                    KeyCode::Esc => {
                        popup_state.input_mode = false;
                        popup_state.input_text.clear();
                        return Ok(AppControlFlow::ShowExitPopup);
                    }
                    KeyCode::Backspace => {
                        if popup_state.input_text.is_empty() {
                            popup_state.input_mode = false;
                            return Ok(AppControlFlow::ShowExitPopup);
                        } else {
                            popup_state.input_text.pop();
                        }
                    }
                    KeyCode::Char(c) => {
                        popup_state.input_text.push(c);
                    }
                    _ => {}
                }
                return Ok(AppControlFlow::ShowExitPopup);
            }

            // é€šå¸¸ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æ“ä½œ
            let popup_result = app.handle_exit_popup_key(key);
            match popup_result {
                ExitPopupResult::SaveAndExit => {
                    // ãƒ‘ã‚¹æœªæŒ‡å®šãªã‚‰ãƒ‘ã‚¹å…¥åŠ›ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
                    if app.target_path.is_none() {
                        if let Some(popup_state) = app.exit_popup_state.as_mut() {
                            popup_state.selected_option = crate::app::ExitPopupOption::SaveAndExit;
                            popup_state.input_mode = true;
                            popup_state.input_text.clear();
                            return Ok(AppControlFlow::ShowExitPopup);
                        } else {
                            // å¿µã®ãŸã‚exit_popup_stateãŒNoneãªã‚‰æ–°è¦ä½œæˆ
                            app.exit_popup_state = Some(Default::default());
                            if let Some(popup_state) = app.exit_popup_state.as_mut() {
                                popup_state.selected_option =
                                    crate::app::ExitPopupOption::SaveAndExit;
                                popup_state.input_mode = true;
                                popup_state.input_text.clear();
                            }
                            return Ok(AppControlFlow::ShowExitPopup);
                        }
                    }
                    // ãƒ‘ã‚¹ãŒã‚ã‚‹å ´åˆã¯ä¿å­˜ã—ã¦çµ‚äº†
                    return Ok(AppControlFlow::TriggerSaveAndExit);
                }
                ExitPopupResult::DiscardAndExit => {
                    return Ok(AppControlFlow::TriggerDiscardAndExit);
                }
                ExitPopupResult::Cancel => return Ok(AppControlFlow::Continue),
                ExitPopupResult::None => return Ok(AppControlFlow::ShowExitPopup),
            }
        }

        // --- é€šå¸¸ã®ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç† ---
        let bindings = &app.config.key_bindings;

        // çµ‚äº†
        if bindings.exit_1.matches(key)
            || bindings.exit_2.matches(key)
            || bindings.exit_3.matches(key)
        {
            app.trigger_exit_popup_if_needed();
            if app.exit_popup_state.is_some() {
                return Ok(AppControlFlow::ShowExitPopup);
            } else {
                msg!(app, "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™ã€‚");
                return Ok(AppControlFlow::Exit);
            }
        }
        // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        else if bindings.save_file.matches(key) {
            if app.target_path.is_none() {
                if app.exit_popup_state.is_none() {
                    app.exit_popup_state = Some(Default::default());
                }
                if let Some(popup_state) = app.exit_popup_state.as_mut() {
                    popup_state.selected_option = crate::app::ExitPopupOption::SaveAndExit;
                    popup_state.input_mode = true;
                    popup_state.input_text.clear();
                }
                return Ok(AppControlFlow::ShowExitPopup);
            }
            match app.save_current_file() {
                Ok(_) => msg!(app, "ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚"),
                Err(e) => emsg!(app, "ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e),
            }
        }
        // Undo/Redo/ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ/ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰é€£æºã‚’è¿½åŠ 
        else if bindings.undo.matches(key) {
            app.editor.undo();
            app.calculate_diff_status();
            msg!(app, "å…ƒã«æˆ»ã—ã¾ã—ãŸã€‚");
        } else if bindings.redo.matches(key) {
            app.editor.redo();
            app.calculate_diff_status();
            msg!(app, "ã‚„ã‚Šç›´ã—ã¾ã—ãŸã€‚");
        } else if bindings.cut.matches(key) {
            if let Some(text) = app.editor.copy_selection() {
                app.clipboard = Some(text.clone());
                app.editor.cut_selection();
                app.calculate_diff_status();
                msg!(app, "é¸æŠç¯„å›²ã‚’åˆ‡ã‚Šå–ã‚Šã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚");
            } else {
                msg!(app, "åˆ‡ã‚Šå–ã‚‹é¸æŠç¯„å›²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
            }
        } else if bindings.copy.matches(key) {
            if let Some(text) = app.editor.copy_selection() {
                app.clipboard = Some(text);
                msg!(app, "é¸æŠç¯„å›²ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚");
            } else {
                msg!(app, "ã‚³ãƒ”ãƒ¼ã™ã‚‹é¸æŠç¯„å›²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
            }
        } else if bindings.paste.matches(key) {
            if let Some(text) = app.clipboard.clone() {
                app.editor.paste_text(&text);
                app.calculate_diff_status();
                msg!(app, "ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã®å†…å®¹ã‚’ãƒšãƒ¼ã‚¹ãƒˆã—ã¾ã—ãŸã€‚");
            } else {
                msg!(app, "ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒç©ºã§ã™ã€‚");
            }
        }
        // å…¨é¸æŠ
        else if bindings.select_all.matches(key) {
            app.editor.select_all();
            msg!(app, "å…¨é¸æŠã—ã¾ã—ãŸã€‚");
        }
        // æŠ˜ã‚Šè¿”ã—è¡¨ç¤ºãƒˆã‚°ãƒ«
        else if bindings.toggle_word_wrap.matches(key) {
            msg!(app,"ç¾åœ¨ã€ã“ã®æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            // app.word_wrap_enabled = !app.word_wrap_enabled;
            // app.calculate_diff_status();
            // if app.word_wrap_enabled {
            //     msg!(app, "æŠ˜ã‚Šè¿”ã—è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰: ON");
            // } else {
            //     msg!(app, "æŠ˜ã‚Šè¿”ã—è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰: OFF");
            // }
        }
        // æ”¹è¡Œ
        else if bindings.insert_newline.matches(key) {
            app.editor.insert_char('\n');
            app.calculate_diff_status();
        }
        // ã‚¿ãƒ–
        else if bindings.insert_tab.matches(key) {
            app.editor.paste_text("    ");
            app.calculate_diff_status();
        }
        // å‰ã®æ–‡å­—ã‚’å‰Šé™¤
        else if bindings.delete_previous_char.matches(key) {
            app.editor.delete_previous_char();
            app.calculate_diff_status();
        }
        // ç¾åœ¨ã®æ–‡å­—ã‚’å‰Šé™¤
        else if bindings.delete_current_char.matches(key) {
            app.editor.delete_current_char();
            app.calculate_diff_status();
        }
        // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•ï¼ˆShiftå¯¾å¿œï¼‰
        else if bindings.move_left.matches(key) {
            app.editor.previous_char(extend_selection);
        } else if bindings.move_right.matches(key) {
            app.editor.next_char(extend_selection);
        } else if bindings.move_up.matches(key) {
            app.editor.previous_line(extend_selection);
        } else if bindings.move_down.matches(key) {
            app.editor.next_line(extend_selection);
        } else if bindings.move_line_start.matches(key) {
            app.editor.move_cursor_to_line_start(extend_selection);
        } else if bindings.move_line_end.matches(key) {
            app.editor.move_cursor_to_line_end(extend_selection);
        } else if bindings.move_document_start.matches(key) {
            app.editor.move_cursor_to_document_start(extend_selection);
        } else if bindings.move_document_end.matches(key) {
            app.editor.move_cursor_to_document_end(extend_selection);
        }
        // é€šå¸¸ã®æ–‡å­—å…¥åŠ›
        else if let KeyCode::Char(c) = key.code {
            if !key.modifiers.contains(KeyModifiers::CONTROL)
                && !key.modifiers.contains(KeyModifiers::ALT)
            {
                app.editor.insert_char(c);
                app.calculate_diff_status();
            }
        }
    }
    Ok(AppControlFlow::Continue)
}
===========
===========src/components.rs
pub mod bottom_bar;
pub mod message_display;
pub mod middle_block;
pub mod popup;
pub mod top_bar;
pub mod search;
pub mod suggest;===========
===========src/lib.rs
pub mod app;
pub mod components;
pub mod config;
pub mod event_handler;
pub mod ui;
===========
===========src/main.rs
use crossterm::{
    event::{self, Event as CEvent},
    execute,
    terminal::{EnterAlternateScreen, LeaveAlternateScreen, disable_raw_mode, enable_raw_mode},
};
use inedit::app::{App, AppControlFlow, MessageType};
use inedit::event_handler;
use inedit::ui;
use ratatui::{Terminal, backend::CrosstermBackend};
use std::{io, time::Duration};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let mut app = App::init();
    let tick_rate = Duration::from_millis(250);

    let res = run_app(&mut terminal, &mut app, tick_rate);

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;

    if let Err(err) = res {
        println!("{:?}", err)
    }

    Ok(())
}

fn run_app(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    app: &mut App,
    _tick_rate: Duration,
) -> io::Result<()> {
    loop {
        terminal.draw(|f| ui::draw_ui(f, app))?;

        // --- ã“ã“ã‚’ä¿®æ­£ ---
        // ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã—ã¦handle_eventã«æ¸¡ã™
        if event::poll(Duration::from_millis(100))? {
            if let CEvent::Key(key_event) = event::read()? {
                let control_flow = event_handler::handle_event(app, &key_event)?;
                match control_flow {
                    AppControlFlow::Exit => {
                        return Ok(());
                    }
                    AppControlFlow::TriggerSaveAndExit => match app.save_current_file() {
                        Ok(_) => return Ok(()),
                        Err(e) => {
                            app.add_message(MessageType::Error, format!("ä¿å­˜ã‚¨ãƒ©ãƒ¼: {}", e));
                        }
                    },
                    AppControlFlow::TriggerDiscardAndExit => {
                        return Ok(());
                    }
                    AppControlFlow::Continue => {
                        // ä½•ã‚‚ã—ãªã„
                    }
                    AppControlFlow::ShowExitPopup => {
                        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤ºä¸­ã¯ãƒ«ãƒ¼ãƒ—ç¶™ç¶š
                    }
                }
            }
        }
    }
}
===========
