===========src/components/bottom_bar.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Modifier, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
}; // App構造体を使用するためにインポート

/// Bottom Bar を描画します。カーソル位置、行数などを表示します。
pub fn render_bottom_bar(f: &mut Frame, area: Rect, app: &App) {
    let cursor_pos = app.editor.cursor.get_current_pos();
    let total_lines = app.editor.buffer.lines().count();
    let _col_count = if let Some(line) = app.editor.buffer.lines().nth(cursor_pos.1 as usize) {
        // 現在の行の論理的な文字数
        line.chars().count()
    } else {
        0
    };

    // テーマの背景色と前景色を取得
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    let text_content = format!(
        " Ln {}, Col {} | Total Lines: {} ",
        cursor_pos.1.saturating_add(1), // 1-indexed line number
        cursor_pos.0.saturating_add(1), // 1-indexed column number
        total_lines
    );

    let paragraph = Paragraph::new(Line::from(text_content))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(theme_bg)),
        ) // テーマの背景色を適用
        .alignment(Alignment::Right) // 右寄せ
        .style(Style::default().fg(theme_fg).add_modifier(Modifier::BOLD)); // テーマの前景色を適用

    f.render_widget(paragraph, area);
}
===========
===========src/components/popup.rs
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Clear, Paragraph},
};

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum ExitPopupOption {
    SaveAndExit,
    DiscardAndExit,
    Cancel,
}

#[derive(Debug, PartialEq, Eq)]
pub enum ExitPopupResult {
    SaveAndExit,
    DiscardAndExit,
    Cancel,
    None,
}

pub struct ExitPopupState {
    pub selected_option: ExitPopupOption,
    pub input_text: String,
    pub input_mode: bool,
}

impl Default for ExitPopupState {
    fn default() -> Self {
        Self {
            selected_option: ExitPopupOption::SaveAndExit,
            input_text: String::new(),
            input_mode: false,
        }
    }
}

impl ExitPopupState {
    pub fn previous(&mut self) {
        self.selected_option = match self.selected_option {
            ExitPopupOption::SaveAndExit => ExitPopupOption::Cancel,
            ExitPopupOption::DiscardAndExit => ExitPopupOption::SaveAndExit,
            ExitPopupOption::Cancel => ExitPopupOption::DiscardAndExit,
        };
    }
    pub fn next(&mut self) {
        self.selected_option = match self.selected_option {
            ExitPopupOption::SaveAndExit => ExitPopupOption::DiscardAndExit,
            ExitPopupOption::DiscardAndExit => ExitPopupOption::Cancel,
            ExitPopupOption::Cancel => ExitPopupOption::SaveAndExit,
        };
    }
}

/// ポップアップの種類
pub enum PopupKind<'a> {
    Exit,
    Input { message: &'a str, input: &'a str },
}

/// ポップアップ描画の共通関数
pub fn render_popup(f: &mut Frame, area: Rect, kind: PopupKind, state: &ExitPopupState) {
    let (title, lines, popup_height) = match kind {
        PopupKind::Exit => {
            let text = vec![
                Line::from(Span::raw("")),
                Line::from(Span::raw(
                    "You have unsaved changes. Do you want to save them?",
                )),
                Line::from(Span::raw("")),
                render_option(
                    state.selected_option,
                    ExitPopupOption::SaveAndExit,
                    "  [S]ave and Exit  ",
                ),
                render_option(
                    state.selected_option,
                    ExitPopupOption::DiscardAndExit,
                    "  [D]iscard and Exit  ",
                ),
                render_option(
                    state.selected_option,
                    ExitPopupOption::Cancel,
                    "  [C]ancel  ",
                ),
                Line::from(Span::raw("")),
            ];
            ("Unsaved Changes", text, 9)
        }
        PopupKind::Input { message, input } => {
            let text = vec![
                Line::from(Span::raw("")),
                Line::from(Span::styled(message, Style::default().fg(Color::Yellow))),
                Line::from(Span::raw("")),
                Line::from(Span::styled(
                    format!("> {}", input),
                    Style::default().fg(Color::White),
                )),
                Line::from(Span::raw("")),
                Line::from(Span::styled(
                    "Backspaceでキャンセル",
                    Style::default().fg(Color::DarkGray),
                )),
            ];
            ("Input", text, 8)
        }
    };

    let block = Block::default()
        .title(Span::styled(
            title,
            Style::default()
                .fg(Color::LightRed)
                .add_modifier(Modifier::BOLD),
        ))
        .title_alignment(Alignment::Center)
        .borders(Borders::ALL)
        .style(Style::default().bg(Color::DarkGray).fg(Color::White));

    let popup_width = 60;
    let popup_area = Rect::new(
        area.width.saturating_sub(popup_width) / 2,
        area.height.saturating_sub(popup_height) / 2,
        popup_width,
        popup_height,
    );

    f.render_widget(Clear, popup_area);
    f.render_widget(
        Paragraph::new(lines)
            .block(block)
            .alignment(Alignment::Center),
        popup_area,
    );
}

fn render_option<'a>(
    current_selection: ExitPopupOption,
    option_type: ExitPopupOption,
    text: &'a str,
) -> Line<'a> {
    let mut style = Style::default().fg(Color::White);
    if current_selection == option_type {
        style = style.add_modifier(Modifier::BOLD).bg(Color::Blue);
    }
    Line::from(Span::styled(text, style))
}
===========
===========src/components/suggest.rs
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};
use crate::app::InputOverlay;
use crate::app::App;

/// サジェストバーや検索・置換バーなどのオーバーレイUIを描画します。
pub fn render_overlay(f: &mut Frame, app: &App) {
    match &app.input_overlay {
        InputOverlay::Search { query, .. } => {
            let area = Rect {
                x: 0,
                y: f.area().height - 2,
                width: f.area().width,
                height: 2,
            };
            let text = format!("🔍 検索: {}", query);
            let para = Paragraph::new(text).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::Replace { query, replace, focus_replace, .. } => {
            let area = Rect {
                x: 0,
                y: f.area().height - 3,
                width: f.area().width,
                height: 3,
            };
            let text = format!(
                "🔍 検索: {}  ⬇ 置換: {}{}",
                query,
                replace,
                if *focus_replace { " ←" } else { "" }
            );
            let para = Paragraph::new(text).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::Suggest { suggestions, selected, .. } => {
            let area = Rect {
                x: 10,
                y: f.area().height - 5,
                width: 30,
                height: suggestions.len().min(5) as u16 + 2,
            };
            let mut lines = vec![];
            for (i, s) in suggestions.iter().enumerate() {
                if i == *selected {
                    lines.push(Line::from(Span::styled(s, Style::default().bg(Color::Blue))));
                } else {
                    lines.push(Line::from(s.as_str()));
                }
            }
            let para = Paragraph::new(lines).block(Block::default().borders(Borders::ALL));
            f.render_widget(para, area);
        }
        InputOverlay::None => {}
    }
}
===========
===========src/components/middle_block/editor_block.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Stylize},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph, Wrap},
};
use syntect::parsing::SyntaxReference;

/// エディタ本体 (テキストとネイティブカーソル) を描画します。
pub fn render_editor_block(f: &mut Frame, area: Rect, app: &App) {
    // 折返しモード対応: wrap幅をword_wrap_enabledで切り替え
    let editor_area_width = super::left_block::get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX // wrapしない場合は非常に大きな値
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let total_visual_lines = visual_lines.len();
    let start = app.editor.scroll_offset_y as usize;
    let end = (start + area.height as usize).min(total_visual_lines);
    let visible_lines = &visual_lines[start..end];

    let mut lines_for_paragraph: Vec<Line> = Vec::new();
    let syntax: &SyntaxReference = app
        .highlighter
        .syntax_set
        .find_syntax_by_name(&app.current_syntax_name)
        .unwrap_or_else(|| app.highlighter.syntax_set.find_syntax_plain_text());

    // 選択範囲のバイトオフセット
    let selection_range = app.editor.get_selection_range();
    let (sel_start_byte, sel_end_byte) = if let Some((sel_start, sel_end)) = selection_range {
        (sel_start, sel_end)
    } else {
        (usize::MAX, usize::MAX)
    };

    // 各visual lineごとに描画
    for (buf_idx, wrap_idx, line_str) in visible_lines.iter() {
        let mut spans: Vec<Span> = Vec::new();
        let highlighted_segments = app.highlighter.highlight_line(line_str, syntax);
        // visual lineのグローバルバイトオフセットを計算
        let global_line_start_byte_offset = app.editor.get_visual_line_global_offset(*buf_idx, *wrap_idx, wrap_width);
        let global_line_end_byte_offset = global_line_start_byte_offset + line_str.len();
        let line_selected = sel_start_byte < global_line_end_byte_offset && sel_end_byte > global_line_start_byte_offset;
        let mut current_byte_offset_in_line = 0;
        for (syntect_style, text) in highlighted_segments {
            let base_style = super::super::super::app::features::syntax::Highlighter::convert_syntect_style_to_ratatui_style(syntect_style);
            let segment_global_start_offset = global_line_start_byte_offset + current_byte_offset_in_line;
            let segment_global_end_offset = segment_global_start_offset + text.len();
            if line_selected {
                let seg_sel_start = sel_start_byte.max(segment_global_start_offset);
                let seg_sel_end = sel_end_byte.min(segment_global_end_offset);
                if seg_sel_start < seg_sel_end {
                    let rel_sel_start = seg_sel_start - segment_global_start_offset;
                    let rel_sel_end = seg_sel_end - segment_global_start_offset;
                    let left = &text[..rel_sel_start];
                    let mid = &text[rel_sel_start..rel_sel_end];
                    let right = &text[rel_sel_end..];
                    if !left.is_empty() {
                        spans.push(Span::styled(left.to_string(), base_style));
                    }
                    if !mid.is_empty() {
                        spans.push(Span::styled(
                            mid.to_string(),
                            base_style.bg(Color::Rgb(50, 50, 100)),
                        ));
                    }
                    if !right.is_empty() {
                        spans.push(Span::styled(right.to_string(), base_style));
                    }
                } else {
                    spans.push(Span::styled(text.to_string(), base_style));
                }
            } else {
                spans.push(Span::styled(text.to_string(), base_style));
            }
            current_byte_offset_in_line += text.len();
        }
        lines_for_paragraph.push(Line::from(spans));
    }
    // ビューポートの高さに満たない場合は空行で埋める
    while lines_for_paragraph.len() < area.height as usize {
        lines_for_paragraph.push(Line::from(vec![Span::raw("")]));
    }
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();
    let mut paragraph = Paragraph::new(Text::from(lines_for_paragraph))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .bg(theme_bg)
                .fg(theme_fg),
        );
    // 折返し表示モードの設定
    if app.word_wrap_enabled {
        paragraph = paragraph.wrap(Wrap { trim: false });
    } else {
        // 折返し無効時はx方向スクロールを有効化
        paragraph = paragraph.scroll((0, app.editor.scroll_offset_x as u16));
    }
    f.render_widget(paragraph, area);
    // カーソル描画
    // visual_lines内で現在のカーソル位置を探す
    let (cursor_visual_idx, cursor_x_in_visual) = app.editor.get_cursor_visual_position(wrap_width);
    let cursor_screen_y = area.y + (cursor_visual_idx as u16).saturating_sub(app.editor.scroll_offset_y);
    let cursor_screen_x = area.x + (cursor_x_in_visual as u16).saturating_sub(app.editor.scroll_offset_x);
    if cursor_screen_x < area.right() && cursor_screen_y < area.bottom() {
        f.set_cursor_position((cursor_screen_x, cursor_screen_y));
    }
}
===========
===========src/components/middle_block/right_block.rs
use crate::app::{App, LineStatus};
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};

/// Right Block を描画します。スクロールバーと差分マーカーを表示します。
pub fn render_right_block(f: &mut Frame, area: Rect, app: &App) {
    // --- 修正: visual line数ベースで計算 ---
    let editor_area_width = crate::components::middle_block::left_block::get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let visual_lines_count = visual_lines.len() as u16;
    let viewport_height = area.height;

    let mut scrollbar_content: Vec<Line> = Vec::new();

    // テーマの背景色を取得
    let theme_bg = app.highlighter.get_background_color();

    // スクロールバーの「つまみ」の位置とサイズを計算
    let thumb_height = if visual_lines_count > 0 {
        ((viewport_height as f32 / visual_lines_count as f32) * viewport_height as f32) as u16
    } else {
        0
    };
    let thumb_height = thumb_height.max(1); // 最小1文字の高さ

    // つまみの上端位置
    let thumb_start_y = if visual_lines_count > 0 {
        ((app.editor.scroll_offset_y as f32 / visual_lines_count as f32) * viewport_height as f32) as u16
    } else {
        0
    };
    let thumb_start_y = thumb_start_y.min(viewport_height.saturating_sub(thumb_height));

    for y_on_screen in 0..viewport_height {
        let mut spans: Vec<Span> = Vec::new();
        let mut line_content = String::new();

        // スクロールバーの描画
        if y_on_screen >= thumb_start_y && y_on_screen < thumb_start_y + thumb_height {
            // つまみの色
            line_content.push('#');
        } else {
            // レール部分の色
            line_content.push('|');
        }
        spans.push(Span::styled(
            line_content,
            Style::default().fg(Color::DarkGray),
        )); // スクロールバーの色は固定

        // 差分マーカーの描画 (visual lineに対応する論理行で判定)
        let visual_idx = (app.editor.scroll_offset_y + y_on_screen) as usize;
        let buf_idx = if visual_idx < visual_lines.len() {
            visual_lines[visual_idx].0
        } else {
            usize::MAX
        };
        if buf_idx != usize::MAX {
            let status = app
                .line_statuses
                .get(buf_idx)
                .copied()
                .unwrap_or(LineStatus::Unchanged);

            let diff_style = match status {
                LineStatus::Modified => Style::default().fg(Color::Yellow),
                LineStatus::Added => Style::default().fg(Color::Green),
                LineStatus::Unchanged => Style::default().fg(Color::DarkGray),
            };
            let marker_char = match status {
                LineStatus::Modified => '~',
                LineStatus::Added => '+',
                LineStatus::Unchanged => ' ',
            };
            spans.push(Span::styled(marker_char.to_string(), diff_style));
        } else {
            spans.push(Span::raw(" "));
        }
        scrollbar_content.push(Line::from(spans));
    }

    let block = Block::default()
        .borders(Borders::LEFT) // 左側に境界線
        .style(Style::default().bg(theme_bg)); // テーマの背景色を適用

    let paragraph = Paragraph::new(scrollbar_content)
        .block(block)
        .alignment(Alignment::Left); // 左寄せ

    f.render_widget(paragraph, area);
}
===========
===========src/components/middle_block/left_block.rs
use crate::app::{App, LineStatus};
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
};

/// エディタ本体の描画幅（Rect.width）を取得する関数
pub fn get_editor_area_width(area: Rect) -> u16 {
    // left_block, right_block, 余白などを考慮してエディタ本体の幅を計算
    // ここでは仮に、全体エリアからleft_block(6)とright_block(3)を引いた幅とする
    // 必要に応じて正確な値に調整してください
    area.width.saturating_sub(6 + 3)
}

/// Left Block を描画します。行番号と差分を表示します。
pub fn render_left_block(f: &mut Frame, area: Rect, app: &App) {
    let mut lines_to_display: Vec<Line> = Vec::new();
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    // 折返しモード対応: エディタ本体のwrap幅でvisual_linesを取得
    let editor_area_width = get_editor_area_width(area);
    let wrap_width = if app.word_wrap_enabled {
        editor_area_width as usize
    } else {
        usize::MAX // wrapしない場合は非常に大きな値
    };
    let visual_lines = app.editor.get_visual_lines_with_width_word_wrap(wrap_width);
    let total_visual_lines = visual_lines.len();
    let start = app.editor.scroll_offset_y as usize;
    let end = (start + area.height as usize).min(total_visual_lines);
    let visible_lines = &visual_lines[start..end];

    // --- 修正: startまでに何個の論理行があったかを数える ---
    // ビューポートの先頭 visual line が属する論理行番号を計算
    let mut logical_line_counter = 1;
    if start > 0 {
        // startまでのvisual_linesでwrap_idx==0の数を数える
        logical_line_counter += visual_lines[..start]
            .iter()
            .filter(|(_, wrap_idx, _)| *wrap_idx == 0)
            .count();
    }
    // 折返し1行目ごとに論理行番号をインクリメントして表示し、折返し2行目以降は空白にする
    for (buf_idx, wrap_idx, _line_str) in visible_lines.iter() {
        if *wrap_idx == 0 {
            // 論理行の先頭 visual line のみ行番号を表示
            let line_number = logical_line_counter.to_string();
            let line_status = app.line_statuses.get(*buf_idx).copied().unwrap_or(LineStatus::Unchanged);
            let diff_symbol_style = match line_status {
                LineStatus::Modified => Style::default().fg(Color::Yellow).add_modifier(ratatui::style::Modifier::BOLD),
                LineStatus::Added => Style::default().fg(Color::Green).add_modifier(ratatui::style::Modifier::BOLD),
                LineStatus::Unchanged => Style::default().fg(Color::DarkGray),
            };
            let diff_symbol = match line_status {
                LineStatus::Modified => "~",
                LineStatus::Added => "+",
                LineStatus::Unchanged => " ",
            };
            let line_num_span = Span::styled(format!("{:>4}", line_number), theme_fg);
            let diff_span = Span::styled(format!("{} ", diff_symbol), diff_symbol_style);
            lines_to_display.push(Line::from(vec![line_num_span, diff_span]));
            logical_line_counter += 1;
        } else {
            // 折返し部分には行番号・差分とも空白
            let line_num_span = Span::styled("    ", Style::default().fg(Color::DarkGray));
            let diff_span = Span::styled("  ", Style::default().fg(Color::DarkGray));
            lines_to_display.push(Line::from(vec![line_num_span, diff_span]));
        }
    }
    // ビューポートの高さに満たない場合は空行で埋める
    while lines_to_display.len() < area.height as usize {
        lines_to_display.push(Line::from(vec![Span::styled(
            "      ",
            Style::default().fg(Color::DarkGray),
        )]));
    }

    let block = Block::default()
        .borders(Borders::RIGHT)
        .style(Style::default().bg(theme_bg));
    let paragraph = Paragraph::new(lines_to_display)
        .block(block)
        .alignment(Alignment::Right);
    f.render_widget(paragraph, area);
}
===========
===========src/components/message_display.rs
// src/components/message_display.rs

use crate::app::{App, MessageType}; // AppとMessageType構造体を使用するためにインポート
use ratatui::{
    Frame,
    layout::Rect,
    style::{Color, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
};
use std::time::Duration; // Durationをインポート

/// アプリケーションのメッセージキューを表示します。（通知スタイル）
pub fn render_message_display(f: &mut Frame, area: Rect, app: &App) {
    const MESSAGE_LIFETIME_SECS: u64 = 3; // メッセージの表示期間（秒）

    // 現在時刻から、表示期間内のメッセージのみをフィルタリング
    let now = std::time::Instant::now();
    let mut visible_messages: Vec<Line> = app
        .messages
        .iter()
        .filter(|(_, _, timestamp)| {
            now.duration_since(*timestamp) < Duration::from_secs(MESSAGE_LIFETIME_SECS)
        })
        .map(|(msg_type, msg_content, _)| {
            let style = match msg_type {
                MessageType::Info => Style::default().fg(Color::Yellow), // 情報メッセージは黄色
                MessageType::Error => Style::default().fg(Color::Red),   // エラーメッセージは赤色
            };
            Line::from(msg_content.clone()).style(style)
        })
        .collect();

    // 最新のメッセージが下に来るように逆順に並べ替え（画面下から上へ表示するため）
    visible_messages.reverse();

    // ui.rs で既に表示エリアの高さが調整されているため、ここでのtruncateは不要です。
    // Paragraphウィジェットは、渡されたTextの行数がarea.heightを超える場合、自動的にクリップします。

    // 表示するメッセージがない場合、または表示エリアの高さが0の場合は描画しない
    if visible_messages.is_empty() || area.height == 0 {
        return;
    }

    let block = Block::default()
        .borders(Borders::NONE) // 境界線
        .style(Style::default().bg(Color::DarkGray)); // 暗い背景色で通知感を出す

    let paragraph = Paragraph::new(visible_messages)
        .block(block)
        .alignment(ratatui::layout::Alignment::Right) // 右寄せ
        .scroll((0, 0)); // スクロールはさせない

    f.render_widget(paragraph, area);
}
===========
===========src/components/top_bar.rs
use crate::app::App;
use ratatui::{
    Frame,
    layout::{Alignment, Rect},
    style::{Modifier, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph},
}; // App構造体を使用するためにインポート

/// Top Bar を描画します。ファイル名、言語、変更状態などを表示します。
pub fn render_top_bar(f: &mut Frame, area: Rect, app: &App) {
    let filename = app
        .target_path
        .as_ref()
        .and_then(|p| p.file_name())
        .and_then(|s| s.to_str())
        .unwrap_or("untitled");

    let modified_indicator = if app.has_unsaved_changes() { "*" } else { "" };

    let current_language = &app.current_syntax_name;
    let current_theme = &app.highlighter.current_theme_name;

    // テーマの背景色と前景色を取得
    let theme_bg = app.highlighter.get_background_color();
    let theme_fg = app.highlighter.get_foreground_color();

    let text_content = format!(
        " {} {}{} | Language: {} | Theme: {} ",
        app.editor.search_query, // 検索クエリがあれば表示
        filename,
        modified_indicator,
        current_language,
        current_theme
    );

    let paragraph = Paragraph::new(Line::from(text_content))
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(theme_bg)),
        ) // テーマの背景色を適用
        .alignment(Alignment::Left) // 左寄せ
        .style(Style::default().fg(theme_fg).add_modifier(Modifier::BOLD)); // テーマの前景色を適用

    f.render_widget(paragraph, area);
}
===========
===========src/components/search.rs
===========
===========src/components/middle_block.rs
pub mod editor_block;
pub mod left_block;
pub mod right_block;
===========
===========src/app.rs
// src/app.rs
pub mod cursor;
pub mod editor;
pub mod features;
pub mod msg;
pub use crate::app::features::syntax::Highlighter;
pub use crate::components::popup::{ExitPopupOption, ExitPopupResult, ExitPopupState};
pub use crate::config::{Config, load_or_create_config, save_config};
use crate::{emsg, msg};
use editor::Editor;
use std::env;
use std::fs;
use std::io;
use std::path::PathBuf;
use std::time::{Duration, Instant}; // Config関連をインポート

/// UIに表示されるメッセージの種類を定義します。
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MessageType {
    Info,
    Error,
}

/// 各行の差分状態を定義します。
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LineStatus {
    Unchanged,
    Modified,
    Added,
}

/// アプリケーションのイベント処理結果を定義します。
#[derive(Debug, PartialEq, Eq)]
pub enum AppControlFlow {
    Continue,              // アプリケーションを通常通り続行
    Exit,                  // アプリケーションを終了
    TriggerSaveAndExit,    // 保存操作を行い、その後終了
    TriggerDiscardAndExit, // 変更を破棄し、その後終了
    ShowExitPopup,         // 終了ポップアップを表示し、ユーザーの入力を待つ
}

pub enum InputOverlay {
    None,
    Search { query: String, cursor: usize },
    Replace { query: String, replace: String, cursor: usize, focus_replace: bool },
    Suggest { prefix: String, suggestions: Vec<String>, selected: usize },
}

/// アプリケーション全体の状態を管理します。
pub struct App {
    pub editor: Editor,
    pub target_path: Option<PathBuf>,
    pub temp_path: Option<PathBuf>,
    pub clipboard: Option<String>,
    pub messages: Vec<(MessageType, String, Instant)>,
    pub original_buffer: String,
    pub word_wrap_enabled: bool,
    pub line_statuses: Vec<LineStatus>,
    pub exit_popup_state: Option<ExitPopupState>,
    pub highlighter: Highlighter,
    pub current_syntax_name: String,
    pub config: Config, // 追加: アプリケーションの設定
    pub input_overlay: InputOverlay,
}

impl Default for App {
    fn default() -> Self {
        // configを先にロードしておく
        let config = load_or_create_config();
        let mut highlighter = Highlighter::new();
        // コンフィグからテーマを初期設定
        highlighter.set_theme(&config.color_theme);

        Self {
            editor: Editor::new(String::new()),
            target_path: None,
            temp_path: None,
            clipboard: None,
            messages: Vec::new(),
            original_buffer: String::new(),
            word_wrap_enabled: false,
            line_statuses: Vec::new(),
            exit_popup_state: None,
            highlighter, // 初期化済みHighlighterを使用
            current_syntax_name: "Plain Text".to_string(),
            config, // 初期化済みconfigを使用
            input_overlay: InputOverlay::None,
        }
    }
}

/// Appがスコープを抜ける際に一時ファイルを削除するためのDrop実装
impl Drop for App {
    fn drop(&mut self) {
        if let Some(path) = &self.temp_path {
            if path.exists() {
                if let Err(e) = fs::remove_file(path) {
                    emsg!(
                        self,
                        "一時ファイル {:?} の削除中にエラーが発生しました: {}",
                        path,
                        e
                    );
                } else {
                    msg!(self, "一時ファイル {:?} を削除しました。", path);
                }
            }
        }
        // アプリケーション終了時に設定を保存
        if let Err(e) = save_config(&self.config) {
            emsg!(self, "Error saving config on exit: {}", e);
        }
    }
}

impl App {
    /// アプリケーションを初期化します。コマンドライン引数からファイルパスを読み込みます。
    pub fn init() -> Self {
        let mut app = Self::default(); // default()でconfigとhighlighterが初期化される

        let args: Vec<String> = env::args().collect();
        let file_path_str_opt = args.get(1);

        if let Some(file_path_str) = file_path_str_opt {
            let original_path = PathBuf::from(file_path_str);
            app.target_path = Some(original_path.clone());

            let temp_filename = format!(
                ".{}.inedit",
                original_path
                    .file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or("untitled")
            );
            let temp_file = PathBuf::from(".");
            let temp_path = original_path
                .parent()
                .unwrap_or(temp_file.as_path())
                .join(temp_filename);
            app.temp_path = Some(temp_path.clone());

            msg!(app, "元のファイルパス: {:?}", original_path);
            msg!(app, "一時ファイルパス: {:?}", temp_path);
            msg!(
                app,
                "ファイルの行数: {}",
                app.editor.buffer.lines().collect::<Vec<&str>>().len()
            );

            // まず一時ファイルからの読み込みを試みる
            if temp_path.exists() {
                match app.editor.load_from_file(&temp_path) {
                    Ok(_) => {
                        msg!(
                            app,
                            "一時ファイル {:?} から正常に読み込みました。",
                            temp_path
                        );
                        app.original_buffer = app.editor.buffer.clone();
                    }
                    Err(e) => {
                        emsg!(
                            app,
                            "一時ファイル {:?} の読み込み中にエラーが発生しました: {}。元のファイルに戻ります。",
                            temp_path,
                            e
                        );
                        if original_path.exists() {
                            match app.editor.load_from_file(&original_path) {
                                Ok(_) => {
                                    msg!(
                                        app,
                                        "元のファイル {:?} を正常に読み込みました。",
                                        original_path
                                    );
                                    app.original_buffer = app.editor.buffer.clone();
                                    if let Err(e) = app.editor.save_to_file(&temp_path) {
                                        emsg!(
                                            app,
                                            "警告: 初期コンテンツを一時ファイル {:?} に書き込めませんでした: {}",
                                            temp_path,
                                            e
                                        );
                                    }
                                }
                                Err(e) => {
                                    emsg!(
                                        app,
                                        "元のファイル {:?} の読み込み中にエラーが発生しました: {}。空のバッファで開始します。",
                                        original_path,
                                        e
                                    );
                                    if let Err(e) = fs::write(&temp_path, "") {
                                        emsg!(
                                            app,
                                            "警告: 空の一時ファイル {:?} を作成できませんでした: {}",
                                            temp_path,
                                            e
                                        );
                                    }
                                }
                            }
                        } else {
                            msg!(
                                app,
                                "元のファイルが存在しません: {:?}。新しいファイルバッファと一時ファイルを作成します。",
                                file_path_str
                            );
                            if let Err(e) = fs::write(&temp_path, "") {
                                emsg!(
                                    app,
                                    "警告: 空の一時ファイル {:?} を作成できませんでした: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                    }
                }
            } else {
                // 一時ファイルが存在しない場合、元のファイルを試す
                if original_path.exists() {
                    match app.editor.load_from_file(&original_path) {
                        Ok(_) => {
                            msg!(
                                app,
                                "元のファイル {:?} を正常に読み込みました。",
                                original_path
                            );
                            app.original_buffer = app.editor.buffer.clone();
                            if let Err(e) = app.editor.save_to_file(&temp_path) {
                                emsg!(
                                    app,
                                    "警告: 初期コンテンツを一時ファイル {:?} に書き込めませんでした: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                        Err(e) => {
                            emsg!(
                                app,
                                "元のファイル {:?} の読み込み中にエラーが発生しました: {}。空のバッファで開始します。",
                                original_path,
                                e
                            );
                            if let Err(e) = fs::write(&temp_path, "") {
                                emsg!(
                                    app,
                                    "警告: 空の一時ファイル {:?} を作成できませんでした: {}",
                                    temp_path,
                                    e
                                );
                            }
                        }
                    }
                } else {
                    msg!(
                        app,
                        "元のファイルが存在しません: {:?}。新しいファイルバッファと一時ファイルを作成します。",
                        file_path_str
                    );
                    if let Err(e) = fs::write(&temp_path, "") {
                        emsg!(
                            app,
                            "警告: 空の一時ファイル {:?} を作成できませんでした: {}",
                            temp_path,
                            e
                        );
                    }
                }
            }
        } else {
            msg!(
                app,
                "ファイルパスが指定されていません。空のバッファ（プレーンテキストモード）で開始します。一時ファイルは作成されません。"
            );
        }

        // ファイル内容とパスに基づいてシンタックスを決定
        let first_lines: String = app
            .editor
            .buffer
            .lines()
            .take(5)
            .collect::<Vec<&str>>()
            .join("\n");
        let syntax = app
            .highlighter
            .get_syntax_for_file(app.target_path.as_deref(), &first_lines);
        app.current_syntax_name = syntax.name.clone();
        msg!(app, "言語: {}", app.current_syntax_name);

        app.calculate_diff_status();
        app
    }

    /// 現在のファイルを保存します。元のファイルパスが設定されている必要があります。
    pub fn save_current_file(&mut self) -> io::Result<()> {
        if let Some(original_path) = &self.target_path {
            self.editor.save_to_file(original_path)?;
            msg!(self, "ファイルは {:?} に保存されました。", original_path);
            self.original_buffer = self.editor.buffer.clone();
            self.calculate_diff_status();

            Ok(())
        } else {
            emsg!(
                self,
                "ファイルを保存するターゲットパスが設定されていません。「名前を付けて保存」機能を使用してください。"
            );
            Err(io::Error::other(
                "ファイルを保存するターゲットパスが設定されていません。「名前を付けて保存」機能を使用してください。",
            ))
        }
    }

    /// メッセージキューに新しいメッセージを追加します。
    pub fn add_message(&mut self, message_type: MessageType, msg: String) {
        self.messages.push((message_type, msg, Instant::now()));
    }

    /// 現在のバッファとオリジナルバッファを比較し、各行の差分状態を計算します。
    pub fn calculate_diff_status(&mut self) {
        self.line_statuses.clear();
        let original_lines: Vec<&str> = self.original_buffer.lines().collect();
        let current_lines: Vec<&str> = self.editor.buffer.lines().collect();

        for (i, current_line) in current_lines.iter().enumerate() {
            if let Some(original_line) = original_lines.get(i) {
                if current_line == original_line {
                    self.line_statuses.push(LineStatus::Unchanged);
                } else {
                    self.line_statuses.push(LineStatus::Modified);
                }
            } else {
                self.line_statuses.push(LineStatus::Added);
            }
        }
    }

    pub fn get_visible_message_count(&self) -> u16 {
        const MESSAGE_LIFETIME_SECS: u64 = 3;
        let now = Instant::now();
        self.messages
            .iter()
            .filter(|(_, _, timestamp)| {
                now.duration_since(*timestamp) < Duration::from_secs(MESSAGE_LIFETIME_SECS)
            })
            .count() as u16
    }

    /// 未保存の変更があるかどうかをチェックします。
    pub fn has_unsaved_changes(&self) -> bool {
        self.editor.buffer != self.original_buffer
    }

    /// 終了を試みます。未保存の変更がある場合はポップアップを表示する状態に設定します。
    pub fn trigger_exit_popup_if_needed(&mut self) {
        if self.has_unsaved_changes() {
            self.exit_popup_state = Some(ExitPopupState::default());
        }
    }

    /// 終了ポップアップのキーイベントを処理します。
    pub fn handle_exit_popup_key(
        &mut self,
        key_event: &crossterm::event::KeyEvent,
    ) -> ExitPopupResult {
        if let Some(state) = &mut self.exit_popup_state {
            match key_event.code {
                crossterm::event::KeyCode::Up => {
                    state.previous();
                    ExitPopupResult::None
                }
                crossterm::event::KeyCode::Down => {
                    state.next();
                    ExitPopupResult::None
                }
                crossterm::event::KeyCode::Enter => {
                    let result = match state.selected_option {
                        ExitPopupOption::SaveAndExit => ExitPopupResult::SaveAndExit,
                        ExitPopupOption::DiscardAndExit => ExitPopupResult::DiscardAndExit,
                        ExitPopupOption::Cancel => ExitPopupResult::Cancel,
                    };
                    self.exit_popup_state = None;
                    result
                }
                crossterm::event::KeyCode::Char('s') | crossterm::event::KeyCode::Char('S') => {
                    self.exit_popup_state = None;
                    ExitPopupResult::SaveAndExit
                }
                crossterm::event::KeyCode::Char('d') | crossterm::event::KeyCode::Char('D') => {
                    self.exit_popup_state = None;
                    ExitPopupResult::DiscardAndExit
                }
                crossterm::event::KeyCode::Char('c')
                | crossterm::event::KeyCode::Char('C')
                | crossterm::event::KeyCode::Esc => {
                    self.exit_popup_state = None;
                    ExitPopupResult::Cancel
                }
                _ => ExitPopupResult::None,
            }
        } else {
            ExitPopupResult::None
        }
    }

    /// Highlighterのテーマを変更します。
    pub fn set_highlighter_theme(&mut self, theme_name: &str) {
        if self.highlighter.set_theme(theme_name) {
            self.config.color_theme = theme_name.to_string(); // Configも更新
            msg!(self, "テーマを '{}' に変更しました。", theme_name);
        } else {
            emsg!(self, "テーマ '{}' は見つかりませんでした。", theme_name);
        }
    }
}
===========
===========src/config.rs
//! アプリケーションの設定（カラーテーマ、キーバインドなど）を管理します。
//! 設定ファイルが存在しない場合はデフォルト設定で作成し、存在する場合は読み込みます。

use crossterm::event::{KeyCode, KeyModifiers};
use directories::ProjectDirs; // クロスプラットフォームな設定ファイルパス解決のため
use serde::{Deserialize, Serialize};
use std::{fs, io, path::PathBuf}; // KeyCodeとKeyModifiersをインポート

const CONFIG_FILE_NAME: &str = "config.yaml";

/// アプリケーション全体のコンフィグレーション
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Config {
    pub color_theme: String,
    pub key_bindings: KeyBindings,
}

/// キーバインドの設定
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KeyBindings {
    // 終了
    pub exit_1: KeyEventConfig, // Ctrl+Q
    pub exit_2: KeyEventConfig, // Ctrl+W
    pub exit_3: KeyEventConfig, // Esc

    // ファイル操作
    pub save_file: KeyEventConfig, // Ctrl+S
    pub open_file: KeyEventConfig, // Ctrl+O (未実装だが予約)

    // 編集操作
    pub copy: KeyEventConfig,                 // Ctrl+C
    pub cut: KeyEventConfig,                  // Ctrl+X
    pub paste: KeyEventConfig,                // Ctrl+V
    pub select_all: KeyEventConfig,           // Ctrl+A
    pub insert_newline: KeyEventConfig,       // Enter
    pub insert_tab: KeyEventConfig,           // Tab
    pub delete_previous_char: KeyEventConfig, // Backspace
    pub delete_current_char: KeyEventConfig,  // Delete

    // Undo/Redo
    pub undo: KeyEventConfig, // Ctrl+Z
    pub redo: KeyEventConfig, // Ctrl+Y

    // カーソル移動
    pub move_left: KeyEventConfig,
    pub move_right: KeyEventConfig,
    pub move_up: KeyEventConfig,
    pub move_down: KeyEventConfig,
    pub move_line_start: KeyEventConfig,     // Home
    pub move_line_end: KeyEventConfig,       // End
    pub move_document_start: KeyEventConfig, // Ctrl+Home (または類似)
    pub move_document_end: KeyEventConfig,   // Ctrl+End (または類似)

    // 機能トグル
    pub toggle_word_wrap: KeyEventConfig, // Alt+Z
}

/// キーイベントをシリアライズ/デシリアライズ可能な形式で表現
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KeyEventConfig {
    pub code: String,           // KeyCodeを文字列で保存 (例: "Char(q)", "Esc", "Left")
    pub modifiers: Vec<String>, // KeyModifiersを文字列のVecで保存 (例: ["Control", "Shift"])
}

impl KeyEventConfig {
    /// `crossterm::event::KeyCode`と`crossterm::event::KeyModifiers`から`KeyEventConfig`を生成
    pub fn from_key_event(code: KeyCode, modifiers: KeyModifiers) -> Self {
        let code_str = format!("{:?}", code);
        let mut modifiers_vec = Vec::new();
        if modifiers.contains(KeyModifiers::CONTROL) {
            modifiers_vec.push("Control".to_string());
        }
        if modifiers.contains(KeyModifiers::ALT) {
            modifiers_vec.push("Alt".to_string());
        }
        if modifiers.contains(KeyModifiers::SHIFT) {
            modifiers_vec.push("Shift".to_string());
        }
        KeyEventConfig {
            code: code_str,
            modifiers: modifiers_vec,
        }
    }

    /// `KeyEventConfig`が指定された`crossterm::event::KeyEvent`と一致するかチェック
    pub fn matches(&self, key_event: &crossterm::event::KeyEvent) -> bool {
        // KeyCodeの比較
        let self_code_str = &self.code;
        let event_code_str = format!("{:?}", key_event.code);
        if self_code_str != &event_code_str {
            return false;
        }

        // --- 修正: self.modifiersが空なら、修飾キー問わずマッチする ---
        if self.modifiers.is_empty() {
            return true;
        }

        // KeyModifiersの比較（self.modifiersが全てevent_modifiers_vecに含まれていればOK）
        let mut event_modifiers_vec = Vec::new();
        if key_event.modifiers.contains(KeyModifiers::CONTROL) {
            event_modifiers_vec.push("Control");
        }
        if key_event.modifiers.contains(KeyModifiers::ALT) {
            event_modifiers_vec.push("Alt");
        }
        if key_event.modifiers.contains(KeyModifiers::SHIFT) {
            event_modifiers_vec.push("Shift");
        }

        self.modifiers
            .iter()
            .all(|m| event_modifiers_vec.contains(&m.as_str()))
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            color_theme: "Solarized (dark)".to_string(), // デフォルトのテーマ名
            key_bindings: KeyBindings::default(),
        }
    }
}

impl Default for KeyBindings {
    fn default() -> Self {
        KeyBindings {
            exit_1: KeyEventConfig::from_key_event(KeyCode::Char('q'), KeyModifiers::CONTROL),
            exit_2: KeyEventConfig::from_key_event(KeyCode::Char('w'), KeyModifiers::CONTROL),
            exit_3: KeyEventConfig::from_key_event(KeyCode::Esc, KeyModifiers::NONE),

            save_file: KeyEventConfig::from_key_event(KeyCode::Char('s'), KeyModifiers::CONTROL),
            open_file: KeyEventConfig::from_key_event(KeyCode::Char('o'), KeyModifiers::CONTROL),

            copy: KeyEventConfig::from_key_event(KeyCode::Char('c'), KeyModifiers::CONTROL),
            cut: KeyEventConfig::from_key_event(KeyCode::Char('x'), KeyModifiers::CONTROL),
            paste: KeyEventConfig::from_key_event(KeyCode::Char('v'), KeyModifiers::CONTROL),
            select_all: KeyEventConfig::from_key_event(KeyCode::Char('a'), KeyModifiers::CONTROL),
            insert_newline: KeyEventConfig::from_key_event(KeyCode::Enter, KeyModifiers::NONE),
            insert_tab: KeyEventConfig::from_key_event(KeyCode::Tab, KeyModifiers::NONE),
            delete_previous_char: KeyEventConfig::from_key_event(
                KeyCode::Backspace,
                KeyModifiers::NONE,
            ),
            delete_current_char: KeyEventConfig::from_key_event(
                KeyCode::Delete,
                KeyModifiers::NONE,
            ),

            // Undo/Redo
            undo: KeyEventConfig::from_key_event(KeyCode::Char('z'), KeyModifiers::CONTROL),
            redo: KeyEventConfig::from_key_event(KeyCode::Char('y'), KeyModifiers::CONTROL),

            move_left: KeyEventConfig::from_key_event(KeyCode::Left, KeyModifiers::NONE),
            move_right: KeyEventConfig::from_key_event(KeyCode::Right, KeyModifiers::NONE),
            move_up: KeyEventConfig::from_key_event(KeyCode::Up, KeyModifiers::NONE),
            move_down: KeyEventConfig::from_key_event(KeyCode::Down, KeyModifiers::NONE),
            move_line_start: KeyEventConfig::from_key_event(KeyCode::Home, KeyModifiers::NONE),
            move_line_end: KeyEventConfig::from_key_event(KeyCode::End, KeyModifiers::NONE),
            move_document_start: KeyEventConfig::from_key_event(
                KeyCode::Home,
                KeyModifiers::CONTROL,
            ), // Ctrl+Home
            move_document_end: KeyEventConfig::from_key_event(KeyCode::End, KeyModifiers::CONTROL), // Ctrl+End

            toggle_word_wrap: KeyEventConfig::from_key_event(KeyCode::Char('z'), KeyModifiers::ALT),
        }
    }
}

/// 設定ファイルのパスを取得します。
/// クロスプラットフォームに対応するため、`directories`クレートを使用します。
fn get_config_path() -> Option<PathBuf> {
    if let Some(proj_dirs) = ProjectDirs::from("com", "inedit", "Inedit") {
        let config_dir = proj_dirs.config_dir();
        if !config_dir.exists() {
            // ディレクトリが存在しない場合は作成を試みる
            if let Err(_e) = fs::create_dir_all(config_dir) {
                // eprintln!("Error creating config directory {:?}: {}", config_dir, e);
                return None;
            }
        }
        Some(config_dir.join(CONFIG_FILE_NAME))
    } else {
        // eprintln!("Could not determine config directory.");
        None
    }
}

/// 設定ファイルを読み込みます。ファイルが存在しない場合はデフォルト設定で作成します。
pub fn load_or_create_config() -> Config {
    if let Some(config_path) = get_config_path() {
        if config_path.exists() {
            match fs::read_to_string(&config_path) {
                Ok(content) => match serde_yaml::from_str(&content) {
                    Ok(config) => {
                        // eprintln!("Config loaded from {:?}", config_path);
                        return config;
                    }
                    Err(_e) => {
                        // eprintln!("Error parsing config file {:?}: {}", config_path, e);
                        // パースエラーの場合はデフォルト設定を返し、上書き保存
                        let default_config = Config::default();
                        if let Err(_e) = save_config(&default_config) {
                            // eprintln!("Error saving default config: {}", e);
                        }
                        return default_config;
                    }
                },
                Err(_e) => {
                    // eprintln!("Error reading config file {:?}: {}", config_path, e);
                    // 読み込みエラーの場合もデフォルト設定を返し、上書き保存
                    let default_config = Config::default();
                    if let Err(_e) = save_config(&default_config) {
                        // eprintln!("Error saving default config: {}", e);
                    }
                    return default_config;
                }
            }
        } else {
            // ファイルが存在しない場合はデフォルト設定で作成
            let default_config = Config::default();
            if let Err(_e) = save_config(&default_config) {
                // eprintln!("Error saving default config: {}", e);
            }
            // eprintln!("Created default config at {:?}", config_path);
            return default_config;
        }
    }
    // コンフィグパスが取得できない場合もデフォルト設定を返す
    // eprintln!("Could not get config path, using default config.");
    Config::default()
}

/// 設定をファイルに保存します。
pub fn save_config(config: &Config) -> io::Result<()> {
    if let Some(config_path) = get_config_path() {
        let yaml_content = serde_yaml::to_string(config).map_err(|e| {
            io::Error::other(
                format!("Failed to serialize config: {}", e),
            )
        })?;
        fs::write(&config_path, yaml_content)?;
        // eprintln!("Config saved to {:?}", config_path);
        Ok(())
    } else {
        Err(io::Error::other(
            "Could not determine config path for saving.",
        ))
    }
}
===========
===========src/app/cursor.rs
// src/app/cursor.rs

/// カーソルの論理的な位置と選択範囲を管理します。
/// この構造体は、テキストバッファの内容やその境界に関する知識を持ちません。
/// 実際のカーソル位置の調整（バッファ境界内へのクランプ）はEditor側で行うべきです。
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub struct Cursor {
    pub x: u16,                              // 列位置 (0-indexed, 文字単位)
    pub y: u16,                              // 行位置 (0-indexed)
    pub selection_start: Option<(u16, u16)>, // 選択範囲の開始位置 (x, y)
}

impl Cursor {
    /// 新しいカーソルを作成します。
    pub fn new(x: u16, y: u16) -> Self {
        Self {
            x,
            y,
            selection_start: None,
        }
    }

    /// カーソル位置を更新します。
    /// このメソッドは、`Editor`が境界チェックを行った後に、最終的なカーソル位置を
    /// 設定するために呼び出すことを想定しています。
    ///
    /// `extend_selection`が`true`の場合、現在のカーソル位置を基準に選択範囲を拡張します。
    /// まだ選択が開始されていない場合は、この呼び出しの前のカーソル位置が選択開始点となります。
    /// `false`の場合、既存の選択範囲はクリアされます。
    pub fn update_position(&mut self, new_x: u16, new_y: u16, extend_selection: bool) {
        if !extend_selection {
            // 選択を拡張しない場合、現在の選択をクリア
            self.clear_selection();
        } else if self.selection_start.is_none() {
            // 選択モードでまだ選択が開始されていない場合、現在の（移動前の）カーソル位置を選択開始点とする
            // 修正箇所: ここで new_x, new_y ではなく self.x, self.y を使用します。
            self.selection_start = Some((self.x, self.y));
        }
        self.x = new_x;
        self.y = new_y;
    }

    /// 現在のカーソル位置を取得します。
    pub fn get_current_pos(&self) -> (u16, u16) {
        (self.x, self.y)
    }

    /// 選択範囲をクリアします。
    pub fn clear_selection(&mut self) {
        self.selection_start = None;
    }

    /// 現在選択中かどうかを返します。
    pub fn is_selecting(&self) -> bool {
        self.selection_start.is_some()
    }

    /// 選択範囲が設定されている場合、正規化された開始点と終了点（(y, x)形式）を返します。
    /// 開始点と終了点は、常に論理的なドキュメント順でソートされます。
    /// 例: `((start_y, start_x), (end_y, end_x))`
    ///
    /// 注意: ここで返される座標は論理的なものであり、バイトオフセットではありません。
    /// バイトオフセットへの変換はEditor側で行う必要があります。
    pub fn get_normalized_selection_coords(&self) -> Option<((u16, u16), (u16, u16))> {
        if let Some(start_pos) = self.selection_start {
            // selection_startは(x, y)形式なので、(y, x)に変換
            let selection_start_y_x = (start_pos.1, start_pos.0);
            let current_pos_y_x = (self.y, self.x);

            // 選択開始点と現在のカーソル位置が同じ場合は選択範囲がない
            if selection_start_y_x == current_pos_y_x {
                None
            } else {
                let mut points = [selection_start_y_x, current_pos_y_x];
                // y座標でソートし、yが同じ場合はx座標でソート
                points.sort_unstable();
                Some((points[0], points[1]))
            }
        } else {
            None
        }
    }
}

// これらのメソッドは、カーソルの「希望する」移動先を計算するためのヘルパーです。
// 実際の最終的なカーソル位置（バッファ境界に合わせたもの）は、Editor側で決定されます。
impl Cursor {
    /// カーソルを1行下に移動したと仮定したY座標を返します。
    pub fn get_potential_next_line_y(&self) -> u16 {
        self.y.saturating_add(1)
    }

    /// カーソルを1行上に移動したと仮定したY座標を返します。
    pub fn get_potential_previous_line_y(&self) -> u16 {
        self.y.saturating_sub(1)
    }

    /// カーソルを1文字右に移動したと仮定したX座標を返します。
    pub fn get_potential_next_char_x(&self) -> u16 {
        self.x.saturating_add(1)
    }

    /// カーソルを1文字左に移動したと仮定したX座標を返します。
    pub fn get_potential_previous_char_x(&self) -> u16 {
        self.x.saturating_sub(1)
    }

    /// カーソルを現在の行の先頭に移動したと仮定したX座標を返します。
    pub fn get_potential_start_of_line_x(&self) -> u16 {
        0
    }

    /// カーソルを現在の行の末尾に移動したと仮定したX座標を返します。
    /// これはEditorが実際の行の長さを考慮して調整する「マーカー」として使用されるべきです。
    pub fn get_potential_end_of_line_x(&self) -> u16 {
        u16::MAX // Editorがこの値を「行末」として解釈することを期待
    }

    /// カーソルをドキュメントの先頭に移動したと仮定したY座標とX座標を返します。
    pub fn get_potential_document_start_pos(&self) -> (u16, u16) {
        (0, 0) // (y, x) 形式
    }

    /// カーソルをドキュメントの末尾に移動したと仮定したY座標とX座標を返します。
    /// これもEditorが実際のドキュメントの行数と最後の行の長さを考慮して調整する「マーカー」として使用されるべきです。
    pub fn get_potential_document_end_pos(&self) -> (u16, u16) {
        (u16::MAX, u16::MAX) // (y, x) 形式。Editorがこの値を「ドキュメント末尾」として解釈することを期待
    }
}
===========
===========src/app/editor.rs
// src/app/editor.rs
pub mod search;
pub mod suggest;
use super::cursor::Cursor;
use arboard::Clipboard; // すでにインポート済み
use ratatui::layout::Rect;
use std::fs;
use std::io;
use std::path::Path;
// use unicode_width::UnicodeWidthChar; // unicode-width は使用しません
use ratatui::text::Line as RatatuiLine; // ratatui::text::Line をエイリアスでインポート

/// テキストバッファとカーソルを管理し、編集操作を提供します。
#[derive(Default)]
pub struct Editor {
    pub buffer: String,
    pub cursor: Cursor,
    pub search_query: String,
    pub search_matches: Vec<(u16, u16)>, // 検索結果の(y, x)位置 (文字単位)
    pub current_search_idx: Option<usize>, // 現在の検索結果のインデックス
    pub scroll_offset_y: u16,            // 垂直方向のスクロールオフセット (行単位)
    pub scroll_offset_x: u16,            // 水平方向のスクロールオフセット (文字単位)
    pub cursor_wrap_idx: usize, // 折返しインデックスを追加
    undo_stack: Vec<String>,
    redo_stack: Vec<String>,
}

impl Editor {
    /// 新しいエディタを作成します。
    pub fn new(initial_text: String) -> Self {
        Self {
            buffer: initial_text,
            cursor: Cursor::new(0, 0),
            search_query: String::new(),
            search_matches: Vec::new(),
            current_search_idx: None,
            scroll_offset_y: 0, // 初期スクロールオフセット
            scroll_offset_x: 0, // 初期スクロールオフセット
            cursor_wrap_idx: 0, // 初期値
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
        }
    }

    /// 指定されたパスからテキストを読み込み、エディタバッファを設定します。
    /// （App層によって、これが元ファイルか一時ファイルかが決定されます。）
    pub fn load_from_file(&mut self, path: &Path) -> io::Result<()> {
        let content = fs::read_to_string(path)?;
        self.buffer = content;
        // ファイルを読み込んだら、カーソルを先頭に設定し、選択をクリア
        self.set_cursor_position(0, 0, false);
        // 新しいファイルの内容なのでスクロールオフセットもリセット
        self.scroll_offset_y = 0;
        self.scroll_offset_x = 0;
        Ok(())
    }

    /// エディタバッファの内容を指定されたパスに書き込みます。
    /// （App層によって、これが元ファイルか一時ファイルかが決定されます。）
    pub fn save_to_file(&self, path: &Path) -> io::Result<()> {
        fs::write(path, &self.buffer)
    }

    /// カーソルを新しい論理位置に移動させます。
    /// バッファの境界を考慮して位置を調整し、その後Cursorの状態を更新します。
    /// `extend_selection`が`true`の場合、選択範囲を維持または開始します。
    pub fn set_cursor_position(&mut self, x: u16, y: u16, extend_selection: bool) {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let num_lines = lines.len();

        let mut final_y = y;
        // Y座標をバッファの行数内にクランプ
        if num_lines == 0 {
            final_y = 0;
        } else {
            final_y = final_y.min((num_lines - 1) as u16);
        }

        let mut final_x = x;
        // X座標を現在の行の文字数内にクランプ
        if num_lines > 0 {
            let current_line_len = lines[final_y as usize].chars().count() as u16;
            // `u16::MAX`が渡された場合は行末に設定
            if x == u16::MAX {
                final_x = current_line_len;
            } else {
                final_x = final_x.min(current_line_len);
            }
        } else {
            final_x = 0;
        }

        // Cursorのupdate_positionメソッドを呼び出し、実際のカーソル位置を更新
        self.cursor
            .update_position(final_x, final_y, extend_selection);

        // カーソル位置の更新後、ビューポートのスクロールオフセットを調整
        // ただし、このメソッドは描画領域のサイズを知らないため、調整は別途 `adjust_viewport_offset` で行う
    }

    /// 描画領域のサイズに基づいてスクロールオフセットを調整し、カーソルが見えるようにします。
    ///
    /// **重要:** このメソッドは`scroll_offset_y`と`scroll_offset_x`を設定します。
    /// 実際の描画を行う際は、`scroll_offset_y`から始まり、`scroll_offset_y + viewport_area.height`までの行を描画するのではなく、
    /// 必ず `self.buffer.lines().count()`（バッファの実際の行数）を超えないようにしてください。
    /// 例えば、`for i in self.scroll_offset_y .. min(self.scroll_offset_y + viewport_area.height, self.buffer.lines().count() as u16)`
    /// のようにループの終端を制限することで、存在しない行が表示されるのを防ぐことができます。
    pub fn adjust_viewport_offset(&mut self, viewport_area: Rect) {
        let cursor_y = self.cursor.y;
        let cursor_x_logical = self.cursor.x; // 論理的な文字インデックス
        let viewport_height = viewport_area.height;
        let viewport_width = viewport_area.width;

        const PADDING_Y: u16 = 3; // 垂直方向のパディング
        const PADDING_X: u16 = 5; // 水平方向のパディング

        // 垂直スクロール (Y軸)
        // カーソルが上端に近づいた場合
        if cursor_y < self.scroll_offset_y + PADDING_Y {
            self.scroll_offset_y = cursor_y.saturating_sub(PADDING_Y);
        }
        // カーソルが下端に近づいた場合
        if cursor_y >= self.scroll_offset_y + viewport_height.saturating_sub(PADDING_Y) {
            self.scroll_offset_y = cursor_y
                .saturating_add(1)
                .saturating_sub(viewport_height)
                .saturating_add(PADDING_Y);
        }

        // 水平スクロール (X軸) - 行の長さとUnicode幅も考慮
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_line_content = if (cursor_y as usize) < lines.len() {
            lines[cursor_y as usize]
        } else {
            ""
        };

        // カーソルの論理X位置 (cursor_x_logical) までの部分文字列の視覚的な幅（セル数）を計算
        let visual_cursor_x_on_line = RatatuiLine::from(
            current_line_content
                .chars()
                .take(cursor_x_logical as usize)
                .collect::<String>(),
        )
        .width() as u16;

        // 現在の行の全幅も計算（スクロール範囲の調整用）
        let current_line_visual_width = RatatuiLine::from(current_line_content).width() as u16;

        if visual_cursor_x_on_line < self.scroll_offset_x + PADDING_X {
            // カーソルがビューポートの左端より左に移動した場合
            self.scroll_offset_x = visual_cursor_x_on_line.saturating_sub(PADDING_X);
        } else if visual_cursor_x_on_line
            >= self.scroll_offset_x + viewport_width.saturating_sub(PADDING_X)
        {
            // カーソルがビューポートの右端より右に移動した場合
            // カーソル自体を含めるため、少なくとも1セル分動かすことを考慮（正確な幅はParagraphが計算する）
            self.scroll_offset_x = visual_cursor_x_on_line
                .saturating_add(1)
                .saturating_sub(viewport_width)
                .saturating_add(PADDING_X);
        }

        // スクロールオフセットがマイナスにならないように、またバッファの範囲を超えないように調整
        let total_lines = self.buffer.lines().count() as u16;
        if total_lines > viewport_height {
            self.scroll_offset_y = self
                .scroll_offset_y
                .min(total_lines.saturating_sub(viewport_height));
        } else {
            self.scroll_offset_y = 0; // コンテンツがビューポートより短い場合、垂直スクロールは不要
        }

        if current_line_visual_width > viewport_width {
            self.scroll_offset_x = self
                .scroll_offset_x
                .min(current_line_visual_width.saturating_sub(viewport_width));
        } else {
            self.scroll_offset_x = 0; // 現在の行がビューポートより短い場合、水平スクロールは不要
        }

        // スクロールオフセットは常に0以上であることを保証
    }

    /// カーソルを次の行に移動します。
    pub fn next_line(&mut self, extend_selection: bool) {
        let potential_y = self.cursor.get_potential_next_line_y();
        let current_x = self.cursor.x; // 現在のX座標を維持しようとする
        self.set_cursor_position(current_x, potential_y, extend_selection);
    }

    /// カーソルを前の行に移動します。
    pub fn previous_line(&mut self, extend_selection: bool) {
        let potential_y = self.cursor.get_potential_previous_line_y();
        let current_x = self.cursor.x; // 現在のX座標を維持しようとする
        self.set_cursor_position(current_x, potential_y, extend_selection);
    }

    /// カーソルを次の文字に移動します。
    pub fn next_char(&mut self, extend_selection: bool) {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y;
        let current_x = self.cursor.x;

        if (current_y as usize) < lines.len() {
            let current_line_len = lines[current_y as usize].chars().count() as u16;
            if current_x < current_line_len {
                // 現在の行内で次の文字へ
                self.set_cursor_position(current_x.saturating_add(1), current_y, extend_selection);
            } else if (current_y as usize + 1) < lines.len() {
                // 次の行が存在する場合
                // 行末にいる場合は次の行の先頭へ
                self.set_cursor_position(0, current_y.saturating_add(1), extend_selection);
            } else {
                // バッファの最後の行の末尾にいる場合は何もしない
                self.set_cursor_position(current_x, current_y, extend_selection); // 現在の位置を再設定（実質何もしない）
            }
        } else {
            // バッファが空または最後の行の末尾（カーソルがその行を超えている）にいる場合は何もしない
            self.set_cursor_position(current_x, current_y, extend_selection); // 現在の位置を再設定（実質何もしない）
        }
    }

    /// カーソルを前の文字に移動します。
    pub fn previous_char(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        let current_x = self.cursor.x;

        if current_x > 0 {
            // 現在の行内で前の文字へ
            self.set_cursor_position(current_x.saturating_sub(1), current_y, extend_selection);
        } else if current_y > 0 {
            // 行頭にいる場合は前の行の末尾へ
            let previous_line_y = current_y.saturating_sub(1);
            // 前の行の実際の長さを取得し、X座標を設定（`u16::MAX`でEditorに「行末」を伝える）
            self.set_cursor_position(u16::MAX, previous_line_y, extend_selection);
        } else {
            // バッファが空または最初の行の先頭にいる場合は何もしない
            self.set_cursor_position(current_x, current_y, extend_selection); // 現在の位置を再設定（実質何もしない）
        }
    }

    /// カーソルを現在の行の先頭に移動します。
    pub fn move_cursor_to_line_start(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        self.set_cursor_position(
            self.cursor.get_potential_start_of_line_x(),
            current_y,
            extend_selection,
        );
    }

    /// カーソルを現在の行の末尾に移動します。
    pub fn move_cursor_to_line_end(&mut self, extend_selection: bool) {
        let current_y = self.cursor.y;
        // u16::MAX を渡して、set_cursor_position に行末を計算させる
        self.set_cursor_position(
            self.cursor.get_potential_end_of_line_x(),
            current_y,
            extend_selection,
        );
    }

    /// カーソルをドキュメントの先頭に移動します。
    pub fn move_cursor_to_document_start(&mut self, extend_selection: bool) {
        let (potential_y, potential_x) = self.cursor.get_potential_document_start_pos();
        self.set_cursor_position(potential_x, potential_y, extend_selection);
    }

    /// カーソルをドキュメントの末尾に移動します。
    pub fn move_cursor_to_document_end(&mut self, extend_selection: bool) {
        let (potential_y, potential_x) = self.cursor.get_potential_document_end_pos();
        // u16::MAX を渡して、set_cursor_position にドキュメントの末尾を計算させる
        self.set_cursor_position(potential_x, potential_y, extend_selection);
    }

    /// 現在のカーソル位置から選択範囲を取得します。
    /// 戻り値は (開始バイトオフセット, 終了バイトオフセット) のタプルです。
    /// 選択範囲がない場合はNoneを返します。
    pub fn get_selection_range(&self) -> Option<(usize, usize)> {
        if let Some((start_coords, end_coords)) = self.cursor.get_normalized_selection_coords() {
            // (y, x) 座標をバイトオフセットに変換するヘルパー関数
            let coords_to_byte_offset = |y_coord: u16, x_coord: u16| -> usize {
                let mut offset = 0;
                for (i, line) in self.buffer.lines().enumerate() {
                    if i == y_coord as usize {
                        // 指定された行と列の文字オフセットまでのバイト数を計算
                        offset += line
                            .chars()
                            .take(x_coord as usize)
                            .map(|c| c.len_utf8())
                            .sum::<usize>();
                        break;
                    }
                    offset += line.len();
                    offset += 1; // 改行文字（LF）のバイト長を仮定
                }
                offset
            };

            let start_byte_offset = coords_to_byte_offset(start_coords.0, start_coords.1);
            let end_byte_offset = coords_to_byte_offset(end_coords.0, end_coords.1);

            // 選択範囲が実際のテキストと重複しないように調整
            if start_byte_offset == end_byte_offset {
                None
            } else {
                Some((start_byte_offset, end_byte_offset))
            }
        } else {
            None
        }
    }

    /// バッファの内容全体を選択します。
    pub fn select_all(&mut self) {
        // 1. 先頭にカーソルを移動し、選択開始
        self.set_cursor_position(0, 0, false); // 選択解除して先頭へ
        // 2. 末尾にカーソルを移動し、選択を拡張
        self.move_cursor_to_document_end(true); // extend_selection = true で末尾まで選択
    }

    /// 選択された範囲のテキストをコピーします。
    /// クリップボードが利用可能ならOSクリップボードにも書き込む
    pub fn copy_selection(&mut self) -> Option<String> {
        if let Some((start, end)) = self.get_selection_range() {
            let text = self.buffer[start..end].to_string();
            // OSクリップボードに書き込む（失敗しても無視）
            if let Ok(mut clipboard) = Clipboard::new() {
                let _ = clipboard.set_text(text.clone());
            }
            Some(text)
        } else {
            None
        }
    }

    /// 選択された範囲のテキストを切り取り、バッファから削除します。
    /// クリップボードが利用可能ならOSクリップボードにも書き込む
    pub fn cut_selection(&mut self) -> Option<String> {
        if let Some((start_byte_offset, end_byte_offset)) = self.get_selection_range() {
            let cut_text = self.buffer[start_byte_offset..end_byte_offset].to_string();

            // OSクリップボードに書き込む（失敗しても無視）
            if let Ok(mut clipboard) = Clipboard::new() {
                let _ = clipboard.set_text(cut_text.clone());
            }

            // 切り取り後のカーソル位置を、選択範囲の開始位置に調整する
            // バイトオフセットから新しいカーソル座標を計算
            let lines_before_cut: Vec<&str> = self.buffer[..start_byte_offset].lines().collect();
            let new_y = (lines_before_cut.len() as u16).saturating_sub(1); // 切り取り開始行
            let new_x = if new_y == u16::MAX {
                // バッファの先頭で切り取りの場合
                0
            } else {
                lines_before_cut
                    .last()
                    .map_or(0, |last_line| last_line.chars().count() as u16)
            };

            self.buffer
                .replace_range(start_byte_offset..end_byte_offset, ""); // 選択範囲を削除

            // カーソル位置を切り取った後の位置に設定し、選択を解除
            self.set_cursor_position(new_x, new_y, false);
            Some(cut_text)
        } else {
            None
        }
    }

    /// 指定されたテキストをカーソル位置にペーストします。
    pub fn paste_text(&mut self, text: &str) {
        if self.cursor.is_selecting() {
            self.cut_selection(); // 選択範囲がある場合はまず切り取る
        }

        let current_offset = self.get_cursor_byte_offset(); // 現在のカーソル位置のバイトオフセット
        self.buffer.insert_str(current_offset, text); // テキストを挿入

        let new_cursor_offset = current_offset + text.len(); // 新しいカーソル位置のバイトオフセット
        self.set_cursor_from_byte_offset(new_cursor_offset, false); // カーソル位置を更新し、選択を解除
    }

    /// OSクリップボードから貼り付ける。失敗した場合はapp.clipboardを使う
    pub fn paste_from_clipboard(&mut self, clipboard: &Option<String>) {
        // OSクリップボードが利用可能ならそちらを優先
        if let Ok(mut sys_clip) = Clipboard::new() {
            if let Ok(text) = sys_clip.get_text() {
                self.paste_text(&text);
                return;
            }
        }
        // 失敗した場合はapp.clipboardを使う
        if let Some(text) = clipboard {
            self.paste_text(text);
        }
    }

    /// カーソル位置に文字を挿入します。
    pub fn insert_char(&mut self, c: char) {
        self.push_undo();
        if self.cursor.is_selecting() {
            self.cut_selection(); // 選択範囲がある場合はまず切り取る
        }

        let current_offset = self.get_cursor_byte_offset(); // 現在のカーソル位置のバイトオフセット
        self.buffer.insert(current_offset, c); // 文字を挿入

        // カーソル位置を更新（改行の場合は次の行の先頭、それ以外はX座標を1進める）
        if c == '\n' {
            self.set_cursor_position(0, self.cursor.y.saturating_add(1), false);
        } else {
            self.set_cursor_position(self.cursor.x.saturating_add(1), self.cursor.y, false);
        }
    }

    /// カーソル位置の文字、または選択範囲を削除します。（Backspace相当）
    pub fn delete_previous_char(&mut self) {
        if self.cursor.is_selecting() {
            self.cut_selection();
            return;
        }

        let current_offset = self.get_cursor_byte_offset(); // 現在のカーソル位置のバイトオフセット
        if current_offset > 0 {
            // 文字の境界を考慮して、前の文字のバイト開始位置を特定
            let mut char_start_offset = current_offset;
            // マルチバイト文字の途中にカーソルがある場合は、文字の先頭まで戻る
            while char_start_offset > 0 && !self.buffer.is_char_boundary(char_start_offset - 1) {
                char_start_offset -= 1;
            }
            if char_start_offset > 0 {
                // 前の文字（char_start_offset - 1 から始まる文字）を削除
                self.buffer.remove(char_start_offset - 1);
                // カーソル位置を新しい位置に調整（選択はクリア）
                self.set_cursor_from_byte_offset(char_start_offset - 1, false);
            }
        }
    }

    /// カーソル位置の文字、または選択範囲を削除します。（Deleteキー相当）
    pub fn delete_current_char(&mut self) {
        if self.cursor.is_selecting() {
            self.cut_selection();
            return;
        }

        let current_offset = self.get_cursor_byte_offset(); // 現在のカーソル位置のバイトオフセット
        if current_offset < self.buffer.len() {
            // 現在のカーソル位置から次の文字のバイト終了位置を特定
            let mut char_start_for_deletion = current_offset;
            // マルチバイト文字の途中にカーソルがある場合は、文字の先頭まで進む
            while char_start_for_deletion < self.buffer.len()
                && !self.buffer.is_char_boundary(char_start_for_deletion)
            {
                char_start_for_deletion += 1;
            }

            // `chars().next()` を使って現在のカーソル位置の文字（または次の文字）のバイト長を取得
            let char_len_to_delete = self.buffer[char_start_for_deletion..]
                .chars()
                .next()
                .map_or(0, |c| c.len_utf8());

            if char_len_to_delete > 0 {
                self.buffer.replace_range(
                    char_start_for_deletion..(char_start_for_deletion + char_len_to_delete),
                    "",
                );
                // Deleteキーの場合、カーソル位置は変更しない（選択はクリア）
                self.set_cursor_position(self.cursor.x, self.cursor.y, false);
            }
        }
    }

    /// 指定された範囲のテキストを新しいテキストで置き換えます。
    pub fn replace_buffer_range(
        &mut self,
        start_byte_offset: usize,
        end_byte_offset: usize,
        new_text: &str,
    ) {
        if start_byte_offset <= end_byte_offset && end_byte_offset <= self.buffer.len() {
            self.buffer
                .replace_range(start_byte_offset..end_byte_offset, new_text);
            let new_cursor_offset = start_byte_offset + new_text.len(); // 置換後の新しいカーソル位置
            self.set_cursor_from_byte_offset(new_cursor_offset, false); // カーソル位置を更新し、選択をクリア
        }
    }

    /// 現在のカーソル位置をバイトオフセットに変換します。
    fn get_cursor_byte_offset(&self) -> usize {
        let mut offset = 0;
        for (current_y, line) in self.buffer.lines().enumerate() {
            if current_y == self.cursor.y as usize {
                // 現在の行のカーソルX位置までのバイト数を計算
                offset += line
                    .chars()
                    .take(self.cursor.x as usize)
                    .map(|c| c.len_utf8())
                    .sum::<usize>();
                break;
            }
            offset += line.len(); // 行のバイト長
            offset += 1; // 改行文字 (LF) のバイト長を仮定
        }
        offset
    }

    /// バイトオフセットからカーソル位置 (x, y) を設定します。
    fn set_cursor_from_byte_offset(&mut self, byte_offset: usize, extend_selection: bool) {
        let mut current_offset = 0;
        let mut y = 0;
        let mut x_chars_count = 0;

        for line in self.buffer.lines() {
            let line_len_bytes = line.len();
            // 改行文字を含む行の全長。Rustのlines()は改行を含まないので、ここで+1する
            let line_with_newline_len = line_len_bytes + 1; // LFを仮定

            // バイトオフセットが現在の行内にあるかチェック
            if byte_offset >= current_offset && byte_offset <= current_offset + line_len_bytes {
                let relative_offset = byte_offset - current_offset;

                x_chars_count = 0;
                let mut current_byte_in_line = 0;
                for c in line.chars() {
                    let char_len_bytes = c.len_utf8();
                    if current_byte_in_line + char_len_bytes > relative_offset {
                        // オフセットが現在の文字の途中にあれば、その文字の先頭にカーソルを置く
                        break;
                    }
                    current_byte_in_line += char_len_bytes;
                    x_chars_count += 1;
                }

                // 行の文字数を超えないように調整
                x_chars_count = x_chars_count.min(line.chars().count());
                break;
            }

            current_offset += line_with_newline_len;
            y += 1;
        }
        // set_cursor_positionを通じて、Cursorのupdate_positionを呼び出す
        self.set_cursor_position(x_chars_count as u16, y as u16, extend_selection);
    }

    /// カーソル位置の括弧に対応する括弧の位置を検索します。
    /// 戻り値は (y, x) のタプルです。
    pub fn find_matching_paren(&self) -> Option<(u16, u16)> {
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y as usize;
        let current_x = self.cursor.x as usize;

        if current_y >= lines.len() {
            return None;
        }

        let current_line_chars: Vec<char> = lines[current_y].chars().collect();
        // カーソルが現在の行の文字数の境界にいる場合も考慮
        if current_x > current_line_chars.len() {
            return None;
        }

        // カーソルが文字の間にいる場合は、その前の文字をチェックする（カーソルがその文字の右側にあるとみなす）
        let char_at_cursor_or_before = if current_x < current_line_chars.len() {
            current_line_chars[current_x]
        } else if current_x > 0 {
            current_line_chars[current_x - 1] // 行末の場合は前の文字を見る
        } else {
            return None; // 空の行の先頭
        };

        let (open_paren, close_paren, direction) = match char_at_cursor_or_before {
            '(' => ('(', ')', 1), // 順方向検索
            '{' => ('{', '}', 1),
            '[' => ('[', ']', 1),
            ')' => ('(', ')', -1), // 逆方向検索
            '}' => ('{', '}', -1),
            ']' => ('[', ']', -1),
            _ => return None, // 括弧ではない
        };

        let mut balance = 0;

        if direction == 1 {
            // 順方向検索 (カーソル位置から終端まで)
            // 現在の行
            for (x_idx, ch) in current_line_chars.iter().enumerate().skip(current_x) {
                if *ch == open_paren {
                    balance += 1;
                } else if *ch == close_paren {
                    balance -= 1;
                }
                if balance == 0 {
                    return Some((current_y as u16, x_idx as u16));
                }
            }
            // 後続の行
            for (y_idx, _item) in lines.iter().enumerate().skip(current_y + 1) {
                let line_chars: Vec<char> = lines[y_idx].chars().collect();
                for (x_idx, ch) in line_chars.iter().enumerate() {
                    if *ch == open_paren {
                        balance += 1;
                    } else if *ch == close_paren {
                        balance -= 1;
                    }
                    if balance == 0 {
                        return Some((y_idx as u16, x_idx as u16));
                    }
                }
            }
        } else {
            // 逆方向検索 (カーソル位置から先頭まで)
            // 現在の行 (カーソル位置の1つ前から逆順に走査)
            let start_x_for_backward_search = if current_x > 0 {
                current_x.saturating_sub(1)
            } else {
                0
            };

            for x_idx in (0..=start_x_for_backward_search).rev() {
                let ch = current_line_chars[x_idx];
                if ch == close_paren {
                    balance += 1;
                } else if ch == open_paren {
                    balance -= 1;
                }
                if balance == 0 {
                    return Some((current_y as u16, x_idx as u16));
                }
            }
            // 前の行
            for y_idx in (0..current_y).rev() {
                let line_chars: Vec<char> = lines[y_idx].chars().collect();
                for x_idx in (0..line_chars.len()).rev() {
                    let ch = line_chars[x_idx];
                    if ch == close_paren {
                        balance += 1;
                    } else if ch == open_paren {
                        balance -= 1;
                    }
                    if balance == 0 {
                        return Some((y_idx as u16, x_idx as u16));
                    }
                }
            }
        }
        None
    }

    /// 現在のカーソル位置からコード補完の候補を取得します。（非常に簡易版）
    /// 実際の補完は、言語サーバープロトコル (LSP) などで行われるのが一般的です。
    pub fn get_completion_suggestions(&self) -> Vec<String> {
        let mut suggestions = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        let current_y = self.cursor.y as usize;

        if current_y >= lines.len() {
            return suggestions;
        }

        let current_line_chars: Vec<char> = lines[current_y].chars().collect();
        let current_x = self.cursor.x as usize;

        // カーソル前の単語を取得
        let mut prefix = String::new();
        // カーソルの1つ前から逆順に走査
        for i in (0..current_x).rev() {
            let ch = current_line_chars[i];
            // 単語を構成する文字（英数字とアンダースコア）を定義
            if ch.is_alphanumeric() || ch == '_' {
                prefix.insert(0, ch); // 正しい順序で単語を構築するため先頭に挿入
            } else {
                break; // 単語以外の文字に遭遇したら停止
            }
        }

        if prefix.is_empty() {
            return suggestions;
        }

        // 仮のキーワードリスト (Rust風)
        let keywords = vec![
            "fn", "let", "if", "else", "while", "for", "match", "loop", "struct", "enum", "use",
            "mod", "pub", "mut", "return", "break", "continue", "impl", "trait", "where", "async",
            "await", "unsafe",
        ];

        // 仮の識別子リスト (バッファ内の単語から取得)
        let mut identifiers: std::collections::HashSet<String> = std::collections::HashSet::new();
        for line_str in self.buffer.lines() {
            // 英数字とアンダースコア以外の文字で単語を分割
            for word in line_str.split(|c: char| !(c.is_alphanumeric() || c == '_')) {
                if !word.is_empty() && !keywords.contains(&word) {
                    identifiers.insert(word.to_string());
                }
            }
        }

        // プレフィックスにマッチするキーワードを追加
        for keyword in keywords {
            if keyword.starts_with(&prefix) {
                suggestions.push(keyword.to_string());
            }
        }

        // プレフィックスにマッチする識別子を追加
        for id in identifiers.iter() {
            if id.starts_with(&prefix) {
                suggestions.push(id.clone());
            }
        }

        suggestions.sort_unstable(); // 候補をソート
        suggestions.dedup(); // 重複を削除
        suggestions
    }

    /// 指定されたクエリでバッファを検索し、マッチ位置を保存します。
    pub fn search(&mut self, query: &str) {
        self.search_query = query.to_string();
        self.search_matches.clear();
        self.current_search_idx = None;

        if query.is_empty() {
            return;
        }

        // 全ての行を走査し、クエリにマッチする位置を収集
        for (y, line) in self.buffer.lines().enumerate() {
            // `match_indices` はバイトオフセットを返すため、文字オフセットに変換が必要
            for (byte_x, _) in line.match_indices(query) {
                // バイトオフセットから文字オフセットに変換
                let char_x = line[..byte_x].chars().count();
                self.search_matches.push((y as u16, char_x as u16));
            }
        }

        if !self.search_matches.is_empty() {
            self.current_search_idx = Some(0);
            let (y, x) = self.search_matches[0];
            self.set_cursor_position(x, y, false); // 最初のマッチ位置にカーソルを移動（選択はクリア）
        }
    }

    /// 次の検索結果に移動します。
    pub fn next_search_match(&mut self) {
        if self.search_matches.is_empty() {
            return;
        }

        let current_cursor_pos = self.cursor.get_current_pos(); // (x, y)
        let mut next_idx_found = false;
        let mut closest_next_idx = 0; // 現在位置より後のマッチがない場合のフォールバック（最初のマッチ）

        // 現在のカーソル位置より「後」にあるマッチを検索
        for (i, &(match_y, match_x)) in self.search_matches.iter().enumerate() {
            // Cursorの座標は (x, y) なので、比較を (y, x) に合わせて行う
            if (match_y > current_cursor_pos.1) || // 次の行
               (match_y == current_cursor_pos.1 && match_x >= current_cursor_pos.0)
            {
                // 同じ行でカーソル位置以降
                closest_next_idx = i;
                next_idx_found = true;
                break;
            }
        }

        // 現在位置より後に見つかった場合はその位置へ
        // 見つからなかった場合は、リストの先頭に戻る (ラップアラウンド)
        let final_idx = if next_idx_found { closest_next_idx } else { 0 };

        self.current_search_idx = Some(final_idx);
        let (y, x) = self.search_matches[final_idx];
        self.set_cursor_position(x, y, false); // 検索結果に移動（選択はクリア）
    }

    /// 前の検索結果に移動します。
    pub fn previous_search_match(&mut self) {
        if self.search_matches.is_empty() {
            return;
        }

        let current_cursor_pos = self.cursor.get_current_pos(); // (x, y)
        let mut prev_idx_found = false;
        let mut closest_prev_idx = self.search_matches.len().saturating_sub(1); // 現在位置より前のマッチがない場合のフォールバック（最後のマッチ）

        // 現在のカーソル位置より「前」にあるマッチを検索 (リストを逆順に走査)
        for (i, &(match_y, match_x)) in self.search_matches.iter().rev().enumerate() {
            let original_idx = self.search_matches.len() - 1 - i; // 元のインデックスに変換
            // Cursorの座標は (x, y) なので、比較を (y, x) に合わせて行う
            if (match_y < current_cursor_pos.1) || // 前の行
               (match_y == current_cursor_pos.1 && match_x <= current_cursor_pos.0)
            {
                // 同じ行でカーソル位置以前
                closest_prev_idx = original_idx;
                prev_idx_found = true;
                break;
            }
        }

        // 現在位置より前に見つからなかった場合は、リストの末尾に戻る (ラップアラウンド)
        let final_idx = if prev_idx_found {
            closest_prev_idx
        } else {
            self.search_matches.len().saturating_sub(1)
        };

        self.current_search_idx = Some(final_idx);
        let (y, x) = self.search_matches[final_idx];
        self.set_cursor_position(x, y, false); // 検索結果に移動（選択はクリア）
    }

    pub fn copy_selection_to_clipboard(&mut self) -> Option<String> {
        if let Some((start, end)) = self.get_selection_range() {
            let text = self.buffer[start..end].to_string();
            let mut clipboard = Clipboard::new().ok();
            if let Some(ref mut cb) = clipboard {
                let _ = cb.set_text(text.clone());
            }
            Some(text)
        } else {
            None
        }
    }

    /// app.clipboardから貼り付ける（OSクリップボードは参照しない）
    // pub fn paste_from_clipboard(&mut self, clipboard: &Option<String>) {
    //     // OSクリップボードが利用可能ならそちらを優先
    //     if let Ok(mut sys_clip) = Clipboard::new() {
    //         if let Ok(text) = sys_clip.get_text() {
    //             self.paste_text(&text);
    //             return;
    //         }
    //     }
    //     // 失敗した場合はapp.clipboardを使う
    //     if let Some(text) = clipboard {
    //         self.paste_text(text);
    //     }
    // }

    /// 編集操作の前に呼び出して履歴を積む
    fn push_undo(&mut self) {
        self.undo_stack.push(self.buffer.clone());
        self.redo_stack.clear();
    }

    pub fn undo(&mut self) {
        if let Some(prev) = self.undo_stack.pop() {
            self.redo_stack.push(self.buffer.clone());
            self.buffer = prev;
            // カーソル位置も復元したい場合は別途保存が必要
        }
    }

    pub fn redo(&mut self) {
        if let Some(next) = self.redo_stack.pop() {
            self.undo_stack.push(self.buffer.clone());
            self.buffer = next;
        }
    }

    /// 折返しモード用: ビューポート高さに合わせた画面上の行リストを返す
    /// 戻り値は (バッファ行番号, 折返しインデックス, 画面行文字列)
    pub fn get_visual_lines(&self) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        // 仮: 1画面行=40文字で折返し（本来はエディタ幅を引数で受けるべき）
        let wrap_width = 40;
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            let mut start = 0;
            let mut wrap_idx = 0;
            let chars: Vec<char> = line.chars().collect();
            while start < chars.len() {
                let end = (start + wrap_width).min(chars.len());
                let visual = chars[start..end].iter().collect::<String>();
                result.push((buf_idx, wrap_idx, visual));
                start = end;
                wrap_idx += 1;
            }
        }
        result
    }
    /// 折返しモード対応: wrap行単位でカーソルを上下移動
    pub fn next_visual_line(&mut self, area_width: usize, extend_selection: bool) {
        let visual_lines = self.get_visual_lines_with_width(area_width);
        let mut found = None;
        for (i, (buf_idx, wrap_idx, _)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                found = Some(i);
                break;
            }
        }
        if let Some(i) = found {
            if i + 1 < visual_lines.len() {
                let (next_buf_idx, next_wrap_idx, next_line) = &visual_lines[i + 1];
                let x = self.cursor.x.min(next_line.chars().count() as u16);
                self.cursor.x = x;
                self.cursor.y = *next_buf_idx as u16;
                self.cursor_wrap_idx = *next_wrap_idx;
                self.cursor.update_position(x, *next_buf_idx as u16, extend_selection);
            }
        }
    }
    pub fn previous_visual_line(&mut self, area_width: usize, extend_selection: bool) {
        let visual_lines = self.get_visual_lines_with_width(area_width);
        let mut found = None;
        for (i, (buf_idx, wrap_idx, _)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                found = Some(i);
                break;
            }
        }
        if let Some(i) = found {
            if i > 0 {
                let (prev_buf_idx, prev_wrap_idx, prev_line) = &visual_lines[i - 1];
                let x = self.cursor.x.min(prev_line.chars().count() as u16);
                self.cursor.x = x;
                self.cursor.y = *prev_buf_idx as u16;
                self.cursor_wrap_idx = *prev_wrap_idx;
                self.cursor.update_position(x, *prev_buf_idx as u16, extend_selection);
            }
        }
    }
    /// 指定幅でwrapしたvisual linesを返す（インデント保持）
    pub fn get_visual_lines_with_width(&self, wrap_width: usize) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            // インデント部分を抽出
            let indent: String = line.chars().take_while(|c| c.is_whitespace()).collect();
            let mut start = 0;
            let mut wrap_idx = 0;
            let chars: Vec<char> = line.chars().collect();
            while start < chars.len() {
                let is_first = wrap_idx == 0;
                let available_width = if is_first || wrap_width == usize::MAX {
                    wrap_width
                } else {
                    wrap_width.saturating_sub(indent.chars().count())
                };
                let end = if available_width == 0 || available_width == usize::MAX {
                    chars.len()
                } else {
                    (start + available_width).min(chars.len())
                };
                let mut visual = chars[start..end].iter().collect::<String>();
                if !is_first && !indent.is_empty() {
                    visual = format!("{}{}", indent, visual);
                }
                result.push((buf_idx, wrap_idx, visual));
                if end == chars.len() { break; }
                start = end;
                wrap_idx += 1;
            }
        }
        result
    }
    /// 指定幅でwrapしたvisual linesを返す（インデント保持、単語単位wrap）
    pub fn get_visual_lines_with_width_word_wrap(&self, wrap_width: usize) -> Vec<(usize, usize, String)> {
        let mut result = Vec::new();
        let lines: Vec<&str> = self.buffer.lines().collect();
        for (buf_idx, line) in lines.iter().enumerate() {
            if line.is_empty() {
                result.push((buf_idx, 0, String::new()));
                continue;
            }
            // インデント部分を抽出
            let indent: String = line.chars().take_while(|c| c.is_whitespace()).collect();
            let mut wrap_idx = 0;
            let mut current = 0;
            let chars: Vec<char> = line.chars().collect();
            let mut first = true;
            while current < chars.len() {
                let available_width = if first || wrap_width == usize::MAX {
                    wrap_width
                } else {
                    wrap_width.saturating_sub(indent.chars().count())
                };
                if available_width == 0 || available_width == usize::MAX {
                    let visual = chars[current..].iter().collect::<String>();
                    result.push((buf_idx, wrap_idx, if first { visual.clone() } else { format!("{}{}", indent, visual) }));
                    break;
                }
                // 単語単位でwrap
                let mut end = current + available_width;
                if end >= chars.len() {
                    end = chars.len();
                } else {
                    // 途中で単語が切れる場合、直前の空白まで戻す
                    let mut back = end;
                    while back > current && !chars[back-1].is_whitespace() {
                        back -= 1;
                    }
                    if back > current {
                        end = back;
                      }
                }
                if end == current {
                    // 1単語がwrap幅を超える場合は強制分割
                    end = (current + wrap_width).min(chars.len());
                }
                let mut visual = chars[current..end].iter().collect::<String>();
                if !first && !indent.is_empty() {
                    visual = format!("{}{}", indent, visual);
                }
                result.push((buf_idx, wrap_idx, visual));
                if end == chars.len() { break; }
                current = end;
                wrap_idx += 1;
                first = false;
            }
        }
        result
    }

    /// 指定したvisual lineのグローバルバイトオフセットを返す（word wrap対応）
    pub fn get_visual_line_global_offset(&self, buf_idx: usize, wrap_idx: usize, wrap_width: usize) -> usize {
        let lines: Vec<&str> = self.buffer.lines().collect();
        if buf_idx >= lines.len() { return 0; }
        let mut offset = 0;
        // buf_idxまでの全行のバイト数+改行
        for i in 0..buf_idx {
            offset += lines[i].len();
            offset += 1; // 改行
        }
        // wrap_idx分だけこの行の先頭からバイト数を加算
        let line = lines[buf_idx];
        let chars: Vec<char> = line.chars().collect();
        let mut current = 0;
        let mut widx = 0;
        let indent_len = line.chars().take_while(|c| c.is_whitespace()).count();
        while widx < wrap_idx && current < chars.len() {
            let available_width = if widx == 0 || wrap_width == usize::MAX {
                wrap_width
            } else {
                wrap_width.saturating_sub(indent_len)
            };
            let mut end = current + available_width;
            if end >= chars.len() {
                end = chars.len();
            } else {
                let mut back = end;
                while back > current && !chars[back-1].is_whitespace() {
                    back -= 1;
                }
                if back > current {
                    end = back;
                }
            }
            if end == current {
                end = (current + available_width).min(chars.len());
            }
            for c in &chars[current..end] {
                offset += c.len_utf8();
            }
            current = end;
            widx += 1;
        }
        offset
    }

    /// 現在のカーソル位置がvisual_linesの何番目か、その中で何文字目かを返す（word wrap対応）
    pub fn get_cursor_visual_position(&self, wrap_width: usize) -> (usize, usize) {
        let visual_lines = self.get_visual_lines_with_width_word_wrap(wrap_width);
        for (i, (buf_idx, wrap_idx, line_str)) in visual_lines.iter().enumerate() {
            if *buf_idx == self.cursor.y as usize && *wrap_idx == self.cursor_wrap_idx {
                // カーソルのxはwrap_idx区間内での相対位置
                let indent_len = line_str.chars().take_while(|c| c.is_whitespace()).count();
                let start = if *wrap_idx == 0 { 0 } else { indent_len };
                let rel_x = self.cursor.x.saturating_sub(start as u16) as usize;
                return (i, rel_x.min(line_str.chars().count()));
            }
        }
        (0, 0)
    }
}
===========
===========src/app/msg.rs
// src/components/msg.rs

/// UI内に表示される情報メッセージをAppのキューに追加するためのマクロ。
///
/// 使用例: `msg!(app, "Hello, world!");`
/// 使用例: `msg!(app, "Value: {}", some_value);`
///
/// 最初の引数として `&mut App` を受け取ります。
#[macro_export]
macro_rules! msg {
    ($app:expr, $($arg:tt)*) => {{
        // `format!`を使ってメッセージ文字列を構築
        let message = format!($($arg)*);
        // Appのadd_messageメソッドを呼び出してメッセージを追加
        $app.add_message($crate::app::MessageType::Info, message);
    }};
}

/// UI内に表示されるエラーメッセージをAppのキューに追加するためのマクロ。
///
/// 使用例: `emsg!(app, "Error: File not found!");`
/// 使用例: `emsg!(app, "Failed with code: {}", error_code);`
///
/// 最初の引数として `&mut App` を受け取ります。
#[macro_export]
macro_rules! emsg {
    ($app:expr, $($arg:tt)*) => {{
        // `format!`を使ってメッセージ文字列を構築
        let message = format!($($arg)*);
        // Appのadd_messageメソッドを呼び出してメッセージを追加
        $app.add_message($crate::app::MessageType::Error, message);
    }};
}

// マクロが外部で利用できるようにするために、これらはルートモジュールで公開される必要があります。
// 例: main.rs の先頭で `#[macro_use] extern crate <your_crate_name>;` を記述するか、
// crate::components::msg を pub use する。
// RataTuiのプロジェクト構造では、通常、`main.rs`で`use crate::msg;`のように直接インポートします。
===========
===========src/app/features/syntax.rs
//! シンタックスハイライト機能と、言語の自動判別ロジックを提供します。
use ratatui::style::{Color, Modifier, Style};
use std::{collections::HashMap, path::Path};
use syntect::{
    easy::HighlightLines,
    highlighting::{Color as SyntectColor, FontStyle, Style as SyntectStyle, Theme, ThemeSet},
    parsing::{SyntaxReference, SyntaxSet},
};
pub mod themes;
/// シンタックスハイライト処理に必要なデータを保持します。
pub struct Highlighter {
    pub syntax_set: SyntaxSet,
    pub theme_set: ThemeSet,
    themes: HashMap<String, Theme>,
    pub current_theme_name: String,
}

impl Default for Highlighter {
    fn default() -> Self {
        let syntax_set = SyntaxSet::load_defaults_newlines();
        let theme_set = ThemeSet::load_defaults();
        let current_theme_name = "Solarized (dark)".to_string(); // デフォルトテーマ

        let mut themes = HashMap::new();
        // ThemeSetから全てのテーマをHashMapにコピーして保持
        for (name, theme) in theme_set.themes.iter() {
            themes.insert(name.clone(), theme.clone());
        }
        for (name, theme) in themes::themes() {
            themes.insert(name, theme);
        }
        Highlighter {
            syntax_set,
            theme_set,
            themes,
            current_theme_name,
        }
    }
}

impl Highlighter {
    /// 新しいHighlighterインスタンスを作成します。
    pub fn new() -> Self {
        Self::default()
    }

    /// ファイルパスから最適なシンタックスを推測します。
    pub fn get_syntax_for_file(&self, path: Option<&Path>, first_lines: &str) -> &SyntaxReference {
        if let Some(path) = path {
            if let Some(extension) = path.extension().and_then(|s| s.to_str()) {
                if let Some(syntax) = self.syntax_set.find_syntax_by_extension(extension) {
                    return syntax;
                }
            }
        }
        // Shebang (例: #!/bin/bash) から言語を推測
        if let Some(syntax) = self.syntax_set.find_syntax_by_first_line(first_lines) {
            return syntax;
        }
        // デフォルトのプレーンテキストを返す
        self.syntax_set.find_syntax_plain_text()
    }

    /// 現在のテーマを取得します。
    pub fn get_current_theme(&self) -> &Theme {
        self.themes
            .get(&self.current_theme_name)
            .unwrap_or_else(|| &self.theme_set.themes["Solarized (dark)"]) // フォールバック
    }

    /// 指定された行に対してシンタックスハイライトを適用し、`syntect`のスタイルとテキストのペアのVecを返します。
    pub fn highlight_line<'a>(
        &self,
        line: &'a str,
        syntax: &SyntaxReference,
    ) -> Vec<(SyntectStyle, &'a str)> {
        let mut highlighter = HighlightLines::new(syntax, self.get_current_theme());
        highlighter
            .highlight_line(line, &self.syntax_set)
            .unwrap_or_else(|_| vec![(SyntectStyle::default(), line)])
    }

    /// `syntect`のスタイルを`ratatui`のスタイルに変換します。
    pub fn convert_syntect_style_to_ratatui_style(s: SyntectStyle) -> Style {
        let mut style = Style::default();

        style = style.fg(convert_syntect_color(s.foreground));
        style = style.bg(convert_syntect_color(s.background));

        if s.font_style.contains(FontStyle::BOLD) {
            style = style.add_modifier(Modifier::BOLD);
        }
        if s.font_style.contains(FontStyle::ITALIC) {
            style = style.add_modifier(Modifier::ITALIC);
        }
        if s.font_style.contains(FontStyle::UNDERLINE) {
            style = style.add_modifier(Modifier::UNDERLINED);
        }
        style
    }

    /// テーマを切り替えます。成功した場合はtrueを返します。
    pub fn set_theme(&mut self, theme_name: &str) -> bool {
        if self.themes.contains_key(theme_name) {
            self.current_theme_name = theme_name.to_string();
            true
        } else {
            // ThemeSetからロードを試みる
            if let Some(theme) = self.theme_set.themes.get(theme_name) {
                self.themes.insert(theme_name.to_string(), theme.clone());
                self.current_theme_name = theme_name.to_string();
                true
            } else {
                false
            }
        }
    }

    /// 利用可能なテーマ名のリストを返します。
    pub fn list_themes(&self) -> Vec<String> {
        let mut themes: Vec<String> = self.theme_set.themes.keys().cloned().collect();
        themes.sort_unstable();
        themes
    }

    /// 現在のテーマの背景色を`ratatui::style::Color`で取得します。
    pub fn get_background_color(&self) -> Color {
        let theme = self.get_current_theme();
        theme
            .settings
            .background
            .map_or(Color::Black, convert_syntect_color)
    }

    /// 現在のテーマの前景色（基本テキスト色）を`ratatui::style::Color`で取得します。
    pub fn get_foreground_color(&self) -> Color {
        let theme = self.get_current_theme();
        theme
            .settings
            .foreground
            .map_or(Color::White, convert_syntect_color)
    }
}

/// `syntect`の`Color`を`ratatui`の`Color`に変換します。
fn convert_syntect_color(c: SyntectColor) -> Color {
    Color::Rgb(c.r, c.g, c.b)
}
===========
===========src/app/features/syntax/themes.rs
use syntect::highlighting::{Color as SyntectColor, Theme, ThemeSettings};

fn midnight_theme() -> (String, Theme) {
    (
        "Midnight".to_string(),
        Theme {
            name: Some("Midnight".to_string()),
            settings: ThemeSettings {
                background: Some(SyntectColor {
                    r: 20,
                    g: 24,
                    b: 31,
                    a: 0xFF,
                }),
                foreground: Some(SyntectColor {
                    r: 220,
                    g: 220,
                    b: 220,
                    a: 0xFF,
                }),
                caret: Some(SyntectColor {
                    r: 80,
                    g: 160,
                    b: 255,
                    a: 0xFF,
                }),
                selection: Some(SyntectColor {
                    r: 60,
                    g: 80,
                    b: 120,
                    a: 0xFF,
                }),
                ..ThemeSettings::default()
            },
            ..Theme::default()
        },
    )
}

fn gruvbox_dark_theme() -> (String, Theme) {
    (
        "Gruvbox Dark".to_string(),
        Theme {
            name: Some("Gruvbox Dark".to_string()),
            settings: ThemeSettings {
                background: Some(SyntectColor {
                    r: 40,
                    g: 40,
                    b: 40,
                    a: 0xFF,
                }),
                foreground: Some(SyntectColor {
                    r: 235,
                    g: 219,
                    b: 178,
                    a: 0xFF,
                }),
                caret: Some(SyntectColor {
                    r: 250,
                    g: 189,
                    b: 47,
                    a: 0xFF,
                }),
                selection: Some(SyntectColor {
                    r: 60,
                    g: 56,
                    b: 54,
                    a: 0xFF,
                }),
                ..ThemeSettings::default()
            },
            ..Theme::default()
        },
    )
}
pub fn themes() -> Vec<(String, Theme)> {
    vec![gruvbox_dark_theme(), midnight_theme()]
}
===========
===========src/app/features.rs
pub mod syntax;
===========
===========src/app/editor/suggest.rs
use std::collections::HashSet;

/// カーソル直前の単語を取得します。
pub fn get_prefix(buffer: &str, cursor_y: u16, cursor_x: u16) -> String {
    let lines: Vec<&str> = buffer.lines().collect();
    if (cursor_y as usize) >= lines.len() {
        return String::new();
    }
    let line = lines[cursor_y as usize];
    let chars: Vec<char> = line.chars().collect();
    let mut prefix = String::new();
    for i in (0..cursor_x as usize).rev() {
        let ch = chars.get(i).copied().unwrap_or('\0');
        if ch.is_alphanumeric() || ch == '_' {
            prefix.insert(0, ch);
        } else {
            break;
        }
    }
    prefix
}

/// 補完候補を返します（Rust風のキーワード＋バッファ内の識別子）。
pub fn get_suggestions(buffer: &str, prefix: &str) -> Vec<String> {
    let keywords = [
        "fn", "let", "if", "else", "while", "for", "match", "loop", "struct", "enum", "use", "mod",
        "pub", "mut", "return", "break", "continue", "impl", "trait", "where", "async", "await",
        "unsafe",
    ];
    let mut suggestions: Vec<String> = keywords
        .iter()
        .filter(|kw| kw.starts_with(prefix))
        .map(|s| s.to_string())
        .collect();

    let mut identifiers = HashSet::new();
    for line in buffer.lines() {
        for word in line.split(|c: char| !(c.is_alphanumeric() || c == '_')) {
            if !word.is_empty() && word.starts_with(prefix) && !keywords.contains(&word) {
                identifiers.insert(word.to_string());
            }
        }
    }
    suggestions.extend(identifiers);
    suggestions.sort();
    suggestions.dedup();
    suggestions
}
===========
===========src/app/editor/search.rs
/// テキストバッファ内でクエリに一致する位置をすべて返します。
/// 戻り値は (行番号, 文字インデックス) のベクタです。
pub fn search_all(buffer: &str, query: &str) -> Vec<(u16, u16)> {
    let mut matches = Vec::new();
    if query.is_empty() {
        return matches;
    }
    for (y, line) in buffer.lines().enumerate() {
        for (byte_x, _) in line.match_indices(query) {
            let char_x = line[..byte_x].chars().count() as u16;
            matches.push((y as u16, char_x));
        }
    }
    matches
}

/// 最初に一致した位置を返します。なければNone。
pub fn search_first(buffer: &str, query: &str) -> Option<(u16, u16)> {
    search_all(buffer, query).into_iter().next()
}===========
===========src/ui.rs
// src/ui.rs
use crate::{
    app::App,
    components::{
        bottom_bar::render_bottom_bar,
        message_display::render_message_display,
        middle_block::editor_block::render_editor_block,
        middle_block::left_block::render_left_block,
        middle_block::right_block::render_right_block,
        popup::{PopupKind, render_popup}, // ← 修正
        top_bar::render_top_bar,
    },
};
use ratatui::{
    Frame,
    layout::{Constraint, Direction, Layout, Rect},
};

/// アプリケーションのUIを描画します。
pub fn draw_ui(f: &mut Frame, app: &mut App) {
    let size = f.area();

    // メインのレイアウトチャンクを定義
    let main_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(1), // Top Bar (タイトル)
                Constraint::Min(0),    // メインエディタ領域（Left + Editor + Right）
                Constraint::Length(1), // Bottom Bar (カーソル位置)
            ]
            .as_ref(),
        )
        .split(size);

    // Top Bar の描画
    render_top_bar(f, main_chunks[0], app);

    // メインエディタ領域をさらに分割 (Left Block + Editor Block + Right Block)
    let editor_area_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints(
            [
                Constraint::Length(7), // Left Block (行番号と差分シンボル、例: " 999 + ")
                Constraint::Min(0),    // Editor Block (エディタ本体)
                Constraint::Length(3), // Right Block (スクロールバーと差分マーカー)
            ]
            .as_ref(),
        )
        .split(main_chunks[1]); // main_chunks[1] がエディタの親領域

    // Middle Block の描画前にスクロールオフセットを調整
    // ここで `editor_area_chunks[1]` (Editor Block の領域) を渡すのが適切です。
    app.editor.adjust_viewport_offset(editor_area_chunks[1]);

    // Left Block の描画
    render_left_block(f, editor_area_chunks[0], app);

    // Editor Block の描画
    render_editor_block(f, editor_area_chunks[1], app);

    // Right Block の描画
    render_right_block(f, editor_area_chunks[2], app);

    // Bottom Bar の描画
    render_bottom_bar(f, main_chunks[2], app);

    // メッセージ通知エリアを計算 (画面全体の右下)
    const MAX_MESSAGE_HEIGHT: u16 = 5;
    const MESSAGE_WIDTH: u16 = 40;
    const MESSAGE_MARGIN: u16 = 1;

    let actual_message_lines = app.get_visible_message_count().min(MAX_MESSAGE_HEIGHT);

    let msg_area = if actual_message_lines > 0 {
        Rect {
            x: size
                .width
                .saturating_sub(MESSAGE_WIDTH)
                .saturating_sub(MESSAGE_MARGIN),
            y: size
                .height
                .saturating_sub(actual_message_lines)
                .saturating_sub(MESSAGE_MARGIN),
            width: MESSAGE_WIDTH,
            height: actual_message_lines,
        }
    } else {
        Rect::new(0, 0, 0, 0)
    };

    // メッセージ通知の描画
    render_message_display(f, msg_area, app);

    // 終了ポップアップが表示されている場合は描画
    if let Some(exit_popup_state) = &app.exit_popup_state {
        if exit_popup_state.input_mode {
            render_popup(
                f,
                size,
                PopupKind::Input {
                    message: "保存先ファイル名を入力してください",
                    input: &exit_popup_state.input_text,
                },
                exit_popup_state,
            );
        } else {
            render_popup(f, size, PopupKind::Exit, exit_popup_state);
        }
    }
}
===========
===========src/event_handler.rs
// src/event_handler.rs

use crate::app::{App, AppControlFlow, ExitPopupResult};
use crate::{emsg, msg}; // ← 修正: appモジュール経由でemsg, msgをインポート
use crossterm::event::{KeyCode, KeyEvent, KeyEventKind, KeyModifiers};

/// イベントを処理し、アプリケーションの状態を更新します。
/// 戻り値はアプリケーションの次の制御フローを示します。
pub fn handle_event(app: &mut App, key: &KeyEvent) -> std::io::Result<AppControlFlow> {
    // キーの押下イベントのみを処理（繰り返しやリリースは無視）
    if key.kind == KeyEventKind::Press {
        let extend_selection = key.modifiers.contains(KeyModifiers::SHIFT);

        // --- ポップアップ表示中の処理 ---
        if let Some(popup_state) = app.exit_popup_state.as_mut() {
            // 入力モード時
            if popup_state.input_mode {
                match key.code {
                    KeyCode::Enter => {
                        if !popup_state.input_text.is_empty() {
                            app.target_path =
                                Some(std::path::PathBuf::from(&popup_state.input_text));
                            popup_state.input_mode = false;
                            popup_state.input_text.clear();
                            // SaveAndExitならexit、そうでなければContinue
                            let is_save_and_exit = matches!(
                                popup_state.selected_option,
                                crate::app::ExitPopupOption::SaveAndExit
                            );
                            app.exit_popup_state = None;
                            match app.save_current_file() {
                                Ok(_) => msg!(app, "ファイルが正常に保存されました。"),
                                Err(e) => emsg!(app, "ファイルの保存に失敗しました: {}", e),
                            }
                            if is_save_and_exit {
                                return Ok(AppControlFlow::TriggerSaveAndExit);
                            } else {
                                return Ok(AppControlFlow::Continue);
                            }
                        } else {
                            popup_state.input_mode = false;
                            msg!(app, "ファイルパスが空です。");
                            return Ok(AppControlFlow::ShowExitPopup);
                        }
                    }
                    KeyCode::Esc => {
                        popup_state.input_mode = false;
                        popup_state.input_text.clear();
                        return Ok(AppControlFlow::ShowExitPopup);
                    }
                    KeyCode::Backspace => {
                        if popup_state.input_text.is_empty() {
                            popup_state.input_mode = false;
                            return Ok(AppControlFlow::ShowExitPopup);
                        } else {
                            popup_state.input_text.pop();
                        }
                    }
                    KeyCode::Char(c) => {
                        popup_state.input_text.push(c);
                    }
                    _ => {}
                }
                return Ok(AppControlFlow::ShowExitPopup);
            }

            // 通常のポップアップ操作
            let popup_result = app.handle_exit_popup_key(key);
            match popup_result {
                ExitPopupResult::SaveAndExit => {
                    // パス未指定ならパス入力ポップアップを表示
                    if app.target_path.is_none() {
                        if let Some(popup_state) = app.exit_popup_state.as_mut() {
                            popup_state.selected_option = crate::app::ExitPopupOption::SaveAndExit;
                            popup_state.input_mode = true;
                            popup_state.input_text.clear();
                            return Ok(AppControlFlow::ShowExitPopup);
                        } else {
                            // 念のためexit_popup_stateがNoneなら新規作成
                            app.exit_popup_state = Some(Default::default());
                            if let Some(popup_state) = app.exit_popup_state.as_mut() {
                                popup_state.selected_option =
                                    crate::app::ExitPopupOption::SaveAndExit;
                                popup_state.input_mode = true;
                                popup_state.input_text.clear();
                            }
                            return Ok(AppControlFlow::ShowExitPopup);
                        }
                    }
                    // パスがある場合は保存して終了
                    return Ok(AppControlFlow::TriggerSaveAndExit);
                }
                ExitPopupResult::DiscardAndExit => {
                    return Ok(AppControlFlow::TriggerDiscardAndExit);
                }
                ExitPopupResult::Cancel => return Ok(AppControlFlow::Continue),
                ExitPopupResult::None => return Ok(AppControlFlow::ShowExitPopup),
            }
        }

        // --- 通常のキーイベント処理 ---
        let bindings = &app.config.key_bindings;

        // 終了
        if bindings.exit_1.matches(key)
            || bindings.exit_2.matches(key)
            || bindings.exit_3.matches(key)
        {
            app.trigger_exit_popup_if_needed();
            if app.exit_popup_state.is_some() {
                return Ok(AppControlFlow::ShowExitPopup);
            } else {
                msg!(app, "アプリケーションを終了します。");
                return Ok(AppControlFlow::Exit);
            }
        }
        // ファイル保存
        else if bindings.save_file.matches(key) {
            if app.target_path.is_none() {
                if app.exit_popup_state.is_none() {
                    app.exit_popup_state = Some(Default::default());
                }
                if let Some(popup_state) = app.exit_popup_state.as_mut() {
                    popup_state.selected_option = crate::app::ExitPopupOption::SaveAndExit;
                    popup_state.input_mode = true;
                    popup_state.input_text.clear();
                }
                return Ok(AppControlFlow::ShowExitPopup);
            }
            match app.save_current_file() {
                Ok(_) => msg!(app, "ファイルが正常に保存されました。"),
                Err(e) => emsg!(app, "ファイルの保存に失敗しました: {}", e),
            }
        }
        // Undo/Redo/テーマ切り替え/クリップボード連携を追加
        else if bindings.undo.matches(key) {
            app.editor.undo();
            app.calculate_diff_status();
            msg!(app, "元に戻しました。");
        } else if bindings.redo.matches(key) {
            app.editor.redo();
            app.calculate_diff_status();
            msg!(app, "やり直しました。");
        } else if bindings.cut.matches(key) {
            if let Some(text) = app.editor.copy_selection() {
                app.clipboard = Some(text.clone());
                app.editor.cut_selection();
                app.calculate_diff_status();
                msg!(app, "選択範囲を切り取りクリップボードにコピーしました。");
            } else {
                msg!(app, "切り取る選択範囲がありません。");
            }
        } else if bindings.copy.matches(key) {
            if let Some(text) = app.editor.copy_selection() {
                app.clipboard = Some(text);
                msg!(app, "選択範囲をクリップボードにコピーしました。");
            } else {
                msg!(app, "コピーする選択範囲がありません。");
            }
        } else if bindings.paste.matches(key) {
            if let Some(text) = app.clipboard.clone() {
                app.editor.paste_text(&text);
                app.calculate_diff_status();
                msg!(app, "クリップボードの内容をペーストしました。");
            } else {
                msg!(app, "クリップボードが空です。");
            }
        }
        // 全選択
        else if bindings.select_all.matches(key) {
            app.editor.select_all();
            msg!(app, "全選択しました。");
        }
        // 折り返し表示トグル
        else if bindings.toggle_word_wrap.matches(key) {
            msg!(app,"現在、この機能は無効化されています。");
            // app.word_wrap_enabled = !app.word_wrap_enabled;
            // app.calculate_diff_status();
            // if app.word_wrap_enabled {
            //     msg!(app, "折り返し表示モード: ON");
            // } else {
            //     msg!(app, "折り返し表示モード: OFF");
            // }
        }
        // 改行
        else if bindings.insert_newline.matches(key) {
            app.editor.insert_char('\n');
            app.calculate_diff_status();
        }
        // タブ
        else if bindings.insert_tab.matches(key) {
            app.editor.paste_text("    ");
            app.calculate_diff_status();
        }
        // 前の文字を削除
        else if bindings.delete_previous_char.matches(key) {
            app.editor.delete_previous_char();
            app.calculate_diff_status();
        }
        // 現在の文字を削除
        else if bindings.delete_current_char.matches(key) {
            app.editor.delete_current_char();
            app.calculate_diff_status();
        }
        // カーソル移動（Shift対応）
        else if bindings.move_left.matches(key) {
            app.editor.previous_char(extend_selection);
        } else if bindings.move_right.matches(key) {
            app.editor.next_char(extend_selection);
        } else if bindings.move_up.matches(key) {
            app.editor.previous_line(extend_selection);
        } else if bindings.move_down.matches(key) {
            app.editor.next_line(extend_selection);
        } else if bindings.move_line_start.matches(key) {
            app.editor.move_cursor_to_line_start(extend_selection);
        } else if bindings.move_line_end.matches(key) {
            app.editor.move_cursor_to_line_end(extend_selection);
        } else if bindings.move_document_start.matches(key) {
            app.editor.move_cursor_to_document_start(extend_selection);
        } else if bindings.move_document_end.matches(key) {
            app.editor.move_cursor_to_document_end(extend_selection);
        }
        // 通常の文字入力
        else if let KeyCode::Char(c) = key.code {
            if !key.modifiers.contains(KeyModifiers::CONTROL)
                && !key.modifiers.contains(KeyModifiers::ALT)
            {
                app.editor.insert_char(c);
                app.calculate_diff_status();
            }
        }
    }
    Ok(AppControlFlow::Continue)
}
===========
===========src/components.rs
pub mod bottom_bar;
pub mod message_display;
pub mod middle_block;
pub mod popup;
pub mod top_bar;
pub mod search;
pub mod suggest;===========
===========src/lib.rs
pub mod app;
pub mod components;
pub mod config;
pub mod event_handler;
pub mod ui;
===========
===========src/main.rs
use crossterm::{
    event::{self, Event as CEvent},
    execute,
    terminal::{EnterAlternateScreen, LeaveAlternateScreen, disable_raw_mode, enable_raw_mode},
};
use inedit::app::{App, AppControlFlow, MessageType};
use inedit::event_handler;
use inedit::ui;
use ratatui::{Terminal, backend::CrosstermBackend};
use std::{io, time::Duration};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let mut app = App::init();
    let tick_rate = Duration::from_millis(250);

    let res = run_app(&mut terminal, &mut app, tick_rate);

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;

    if let Err(err) = res {
        println!("{:?}", err)
    }

    Ok(())
}

fn run_app(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    app: &mut App,
    _tick_rate: Duration,
) -> io::Result<()> {
    loop {
        terminal.draw(|f| ui::draw_ui(f, app))?;

        // --- ここを修正 ---
        // キーイベントを取得してhandle_eventに渡す
        if event::poll(Duration::from_millis(100))? {
            if let CEvent::Key(key_event) = event::read()? {
                let control_flow = event_handler::handle_event(app, &key_event)?;
                match control_flow {
                    AppControlFlow::Exit => {
                        return Ok(());
                    }
                    AppControlFlow::TriggerSaveAndExit => match app.save_current_file() {
                        Ok(_) => return Ok(()),
                        Err(e) => {
                            app.add_message(MessageType::Error, format!("保存エラー: {}", e));
                        }
                    },
                    AppControlFlow::TriggerDiscardAndExit => {
                        return Ok(());
                    }
                    AppControlFlow::Continue => {
                        // 何もしない
                    }
                    AppControlFlow::ShowExitPopup => {
                        // ポップアップ表示中はループ継続
                    }
                }
            }
        }
    }
}
===========
